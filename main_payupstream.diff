diff --git a/PULL_REQUEST.md b/PULL_REQUEST.md
new file mode 100644
index 0000000..e69de29
diff --git a/docs/chandler-functional-design.md b/docs/chandler-functional-design.md
new file mode 100644
index 0000000..52449aa
--- /dev/null
+++ b/docs/chandler-functional-design.md
@@ -0,0 +1,673 @@
+# Chandler Module - Functional Design Document
+
+## Overview
+
+The Chandler module is responsible for managing upstream TollGate connections on behalf of our TollGate device. It acts as the financial and session management layer that makes decisions about connecting to and paying for upstream TollGate services. The Chandler receives signals from the Crowsnest module about discovered upstream TollGates and manages the entire lifecycle of upstream connections including budget decisions, payments, session management, and usage tracking.
+
+## Responsibilities
+
+- Receive upstream TollGate discovery signals from Crowsnest
+- Make financial decisions about connecting to upstream TollGates
+- Manage budget and spending limits for upstream connections
+- Create and manage payment sessions with upstream TollGates
+- Track usage and handle automatic renewals based on thresholds
+- Store and manage session state for active upstream connections
+- Handle upstream TollGate disconnections and cleanup
+
+## Architecture
+
+### Core Components
+
+#### 1. SessionManager
+- **Purpose**: Manage active sessions with upstream TollGates
+- **Implementation**: Maps pubkey to session information, stores session events locally
+- **State**: Track session creation, allotment, usage, and renewal history
+
+#### 2. PaymentDecisionEngine
+- **Purpose**: Make decisions about whether to start/continue sessions
+- **Implementation**: Budget checking, trust verification, price validation
+- **Decisions**: Within budget? Trust pubkey? Acceptable pricing?
+
+#### 3. UsageTracker System
+- **Purpose**: Monitor usage and trigger renewal callbacks
+- **Implementation**: Separate tracker implementations per metric type
+- **Types**: TimeUsageTracker (milliseconds), DataUsageTracker (bytes)
+
+#### 4. PaymentClient
+- **Purpose**: Create and send payment events to upstream TollGates
+- **Implementation**: Simple Nostr event creation and HTTP POST to upstream
+- **Protocol**: Creates payment events (kind 21000), processes session responses (kind 1022)
+
+## Data Structures
+
+### ChandlerSession
+```go
+type ChandlerSession struct {
+    // Upstream TollGate identification
+    UpstreamPubkey    string             // TollGate pubkey (primary key)
+    InterfaceName     string             // Network interface name
+    GatewayIP         string             // Gateway IP address
+    
+    // Advertisement and pricing
+    Advertisement     *nostr.Event       // Current advertisement (kind 10021)
+    Metric            string             // "milliseconds" or "bytes"
+    StepSize          uint64             // Step size from advertisement
+    PricingOptions    []PricingOption    // Available pricing options from advertisement
+    SelectedPricing   *PricingOption     // Currently selected pricing option
+    
+    // Session state
+    SessionEvent      *nostr.Event       // Active session event (kind 1022)
+    TotalAllotment    uint64             // Total allotment purchased
+    
+    // Usage tracking
+    UsageTracker      UsageTrackerInterface // Active usage tracker
+    RenewalThresholds []float64          // Renewal thresholds (e.g., 0.5, 0.8, 0.9)
+    LastRenewalAt     time.Time          // Last renewal timestamp
+    
+    // Session metadata
+    CreatedAt         time.Time          // Session creation time
+    LastPaymentAt     time.Time          // Last payment timestamp
+    TotalSpent        uint64             // Total sats spent on this session
+    PaymentCount      int                // Number of payments made
+    Status            SessionStatus      // Active, Paused, Expired, etc.
+}
+
+type PricingOption struct {
+    AssetType        string             // "cashu"
+    PricePerStep     uint64             // Price per step in units
+    PriceUnit        string             // Price unit (e.g., "sat")
+    MintURL          string             // Accepted mint URL
+    MinSteps         uint64             // Minimum steps to purchase
+}
+
+type SessionStatus int
+
+const (
+    SessionActive SessionStatus = iota
+    SessionPaused
+    SessionExpired
+    SessionError
+)
+```
+
+### UsageTrackerInterface
+```go
+type UsageTrackerInterface interface {
+    // Start monitoring usage for the given session
+    Start(session *ChandlerSession, chandler ChandlerInterface) error
+    
+    // Stop monitoring and cleanup
+    Stop() error
+    
+    // Get current usage amount
+    GetCurrentUsage() uint64
+    
+    // Update usage amount (for external updates)
+    UpdateUsage(amount uint64) error
+    
+    // Set renewal thresholds
+    SetRenewalThresholds(thresholds []float64) error
+}
+```
+
+### TimeUsageTracker
+```go
+type TimeUsageTracker struct {
+    session       *ChandlerSession
+    chandler      ChandlerInterface
+    startTime     time.Time
+    pausedTime    time.Duration
+    thresholds    []float64
+    ticker        *time.Ticker
+    done          chan bool
+    mu            sync.RWMutex
+}
+```
+
+### DataUsageTracker
+```go
+type DataUsageTracker struct {
+    session       *ChandlerSession
+    chandler      ChandlerInterface
+    interfaceName string
+    startBytes    uint64
+    currentBytes  uint64
+    thresholds    []float64
+    ticker        *time.Ticker
+    done          chan bool
+    mu            sync.RWMutex
+}
+```
+
+### PaymentProposal
+```go
+type PaymentProposal struct {
+    UpstreamPubkey     string         // Target upstream TollGate
+    Steps              uint64         // Number of steps to purchase
+    PricingOption      *PricingOption // Selected pricing option
+    Reason             string         // "initial", "renewal", "extension"
+    EstimatedAllotment uint64         // Expected allotment
+}
+```
+
+## Core Interfaces
+
+### Enhanced ChandlerInterface
+```go
+type ChandlerInterface interface {
+    // Called by Crowsnest when upstream TollGate discovered
+    HandleUpstreamTollgate(upstream *UpstreamTollgate) error
+    
+    // Called by Crowsnest when network interface disconnects
+    HandleDisconnect(interfaceName string) error
+    
+    // Called by UsageTracker when renewal threshold reached
+    HandleUpcomingRenewal(upstreamPubkey string, currentUsage uint64) error
+    
+    // Management methods
+    GetActiveSessions() map[string]*ChandlerSession
+    GetSessionByPubkey(pubkey string) (*ChandlerSession, error)
+    GetBudgetStatus() *BudgetStatus
+    
+    // Control methods
+    PauseSession(pubkey string) error
+    ResumeSession(pubkey string) error
+    TerminateSession(pubkey string) error
+}
+```
+
+```
+
+## Workflow
+
+### Upstream TollGate Discovery Workflow
+
+```mermaid
+graph TD
+    A[Crowsnest Discovers Upstream] --> B[HandleUpstreamTollgate Called]
+    B --> C[Extract Advertisement Details]
+    C --> D[Check Trust Policy]
+    D --> E{Trusted Pubkey?}
+    E -->|No| F[Log Rejection - Untrusted]
+    E -->|Yes| G[Parse Pricing Information]
+    G --> H[Create Payment Proposal]
+    H --> I[Check Budget Constraints]
+    I --> J{Within Budget?}
+    J -->|No| K[Log Rejection - Budget]
+    J -->|Yes| L[Create Initial Payment]
+    L --> M[Send Payment to Upstream]
+    M --> N{Payment Accepted?}
+    N -->|No| O[Log Payment Failure]
+    N -->|Yes| P[Store Session Event]
+    P --> Q[Create Usage Tracker]
+    Q --> R[Start Usage Monitoring]
+    R --> S[Log Session Active]
+    
+    F --> T[Continue Monitoring]
+    K --> T
+    O --> T
+    S --> T
+```
+
+### Session Management Workflow
+
+```mermaid
+graph TD
+    A[Session Active] --> B[Usage Tracker Monitoring]
+    B --> C{Threshold Reached?}
+    C -->|No| B
+    C -->|Yes| D[HandleUpcomingRenewal Called]
+    D --> E[Check Current Advertisement]
+    E --> F{Advertisement Changed?}
+    F -->|Yes| G[Log Warning - Ad Changed]
+    F -->|No| H[Create Renewal Proposal]
+    G --> H
+    H --> I[Check Budget for Renewal]
+    I --> J{Can Afford Renewal?}
+    J -->|No| K[Log Budget Exhausted]
+    J -->|Yes| L[Calculate Renewal Amount]
+    L --> M[Send Renewal Payment]
+    M --> N{Payment Successful?}
+    N -->|No| O[Log Renewal Failed]
+    N -->|Yes| P[Update Session Allotment]
+    P --> Q[Update Usage Tracker]
+    Q --> R[Log Renewal Success]
+    
+    K --> S[Pause Session]
+    O --> S
+    R --> B
+    S --> T[Wait for Budget/Manual Resume]
+```
+
+### Payment Creation and Processing Workflow
+
+```mermaid
+graph TD
+    A[Create Payment Proposal] --> B[Get Customer Identity]
+    B --> C[Create Payment Event]
+    C --> D[Add Payment Tags]
+    D --> E[Add Device Identifier]
+    E --> F[Sign Payment Event]
+    F --> G[Send HTTP POST to Upstream]
+    G --> H{HTTP Response?}
+    H -->|200 OK| I[Parse Session Event]
+    H -->|402 Payment Required| J[Log Payment Rejected]
+    H -->|Other Error| K[Log Communication Error]
+    I --> L[Validate Session Event]
+    L --> M{Valid Session?}
+    M -->|Yes| N[Store Session Event]
+    M -->|No| O[Log Invalid Session]
+    N --> P[Calculate Allotment]
+    P --> Q[Return Success]
+    
+    J --> R[Return Payment Error]
+    K --> R
+    O --> R
+    Q --> S[Continue]
+    R --> S
+```
+
+## Error Handling
+
+### Error Categories
+
+1. **Discovery Errors**
+   - Invalid advertisement format
+   - Unsupported metric types
+   - Missing pricing information
+   - Signature verification failures
+
+2. **Trust Errors**
+   - Pubkey not in allowlist
+   - Pubkey in blocklist
+   - Identity verification failures
+
+3. **Budget Errors**
+   - Price exceeds maximum per unit
+   - Daily budget exhausted
+   - Maximum sessions reached
+   - Insufficient funds
+
+4. **Payment Errors**
+   - HTTP communication failures
+   - Payment rejection by upstream
+   - Invalid session response
+   - Token generation failures
+
+5. **Session Errors**
+   - Session creation failures
+   - Usage tracking errors
+   - Renewal failures
+   - Session expiration
+
+### Error Handling Strategy
+
+```go
+type ChandlerError struct {
+    Type        ErrorType
+    Code        string
+    Message     string
+    Cause       error
+    UpstreamPubkey string
+    Context     map[string]interface{}
+}
+
+type ErrorType int
+
+const (
+    ErrorTypeDiscovery ErrorType = iota
+    ErrorTypeTrust
+    ErrorTypeBudget
+    ErrorTypePayment
+    ErrorTypeSession
+    ErrorTypeUsageTracking
+)
+```
+
+### Logging Strategy
+
+- **Level**: Use structured logging with consistent fields
+- **Context**: Include upstream pubkey, interface name, and session ID
+- **Security**: Never log private keys or sensitive payment data
+- **Performance**: Log session metrics for analysis
+
+#### Example Log Messages
+
+```go
+// Discovery
+log.Printf("Upstream TollGate discovered: pubkey=%s, interface=%s, price=%d %s per %s", 
+    pubkey, interfaceName, pricePerStep, priceUnit, metric)
+
+// Budget decision
+log.Printf("Payment proposal within budget: pubkey=%s, amount=%d sats, steps=%d", 
+    pubkey, amount, steps)
+
+// Session creation
+log.Printf("Session created with upstream: pubkey=%s, allotment=%d %s, session_id=%s", 
+    pubkey, allotment, metric, sessionID)
+
+// Usage tracking
+log.Printf("Usage threshold reached: pubkey=%s, threshold=%.1f%%, usage=%d/%d %s", 
+    pubkey, threshold*100, used, total, metric)
+
+// Renewal
+log.Printf("Session renewed: pubkey=%s, additional_allotment=%d %s, total_spent=%d sats", 
+    pubkey, additionalAllotment, metric, totalSpent)
+
+// Advertisement change
+log.Printf("WARNING: Upstream advertisement changed: pubkey=%s, old_price=%d, new_price=%d", 
+    pubkey, oldPrice, newPrice)
+```
+
+## Configuration
+
+### Configuration Structure
+```go
+type ChandlerConfig struct {
+    // Simple budget settings
+    MaxPricePerMillisecond float64 `json:"max_price_per_millisecond"` // Max sats per ms (can be fractional)
+    MaxPricePerByte        float64 `json:"max_price_per_byte"`        // Max sats per byte (can be fractional)
+    
+    // Trust settings
+    Trust TrustConfig `json:"trust"`
+    
+    // Session settings
+    Sessions SessionConfig `json:"sessions"`
+    
+    // Usage tracking settings
+    UsageTracking UsageTrackingConfig `json:"usage_tracking"`
+}
+
+type TrustConfig struct {
+    DefaultPolicy string   `json:"default_policy"` // "trust_all", "trust_none"
+    Allowlist     []string `json:"allowlist"`      // Trusted pubkeys
+    Blocklist     []string `json:"blocklist"`      // Blocked pubkeys
+}
+
+type SessionConfig struct {
+    DefaultRenewalThresholds            []float64 `json:"default_renewal_thresholds"`            // [0.5, 0.8, 0.9]
+    PreferredSessionIncrementsMilliseconds uint64    `json:"preferred_session_increments_milliseconds"` // Preferred increment for time sessions
+    PreferredSessionIncrementsBytes        uint64    `json:"preferred_session_increments_bytes"`        // Preferred increment for data sessions
+    RenewalStepMultiplier               float64   `json:"renewal_step_multiplier"`               // Multiplier for renewal amounts
+}
+
+type UsageTrackingConfig struct {
+    MonitoringInterval    time.Duration `json:"monitoring_interval"`     // How often to check usage
+    TimeTracker          TimeTrackerConfig `json:"time_tracker"`
+    DataTracker          DataTrackerConfig `json:"data_tracker"`
+}
+
+type TimeTrackerConfig struct {
+    Enabled           bool          `json:"enabled"`
+    PrecisionMs       uint64        `json:"precision_ms"`       // Tracking precision in milliseconds
+}
+
+type DataTrackerConfig struct {
+    Enabled           bool          `json:"enabled"`
+    InterfacePattern  string        `json:"interface_pattern"`   // Pattern to match interfaces
+    MonitoringInterval time.Duration `json:"monitoring_interval"` // How often to check data usage
+}
+```
+
+### Default Configuration
+```json
+{
+    "max_price_per_millisecond": 0.002777777778, // 10k sats/hr
+    "max_price_per_byte": 0.00003725782414, // 5k stats/gbit
+    "trust": {
+        "default_policy": "trust_all",
+        "allowlist": [],
+        "blocklist": []
+    },
+    "sessions": {
+        "default_renewal_thresholds": [0.5, 0.8, 0.9],
+        "preferred_session_increments_milliseconds": 60000,
+        "preferred_session_increments_bytes": 1048576,
+        "renewal_step_multiplier": 1.0
+    },
+    "usage_tracking": {
+        "monitoring_interval": "10s",
+        "time_tracker": {
+            "enabled": true,
+            "precision_ms": 1000
+        },
+        "data_tracker": {
+            "enabled": true,
+            "interface_pattern": "*",
+            "monitoring_interval": "5s"
+        }
+    }
+}
+```
+
+## Integration Points
+
+### Main Application Integration
+
+```go
+// In main.go or init function
+func initChandler() {
+    chandlerInstance, err := chandler.NewChandler(configManager)
+    if err != nil {
+        log.Fatalf("Failed to create chandler instance: %v", err)
+    }
+    
+    // Set chandler for crowsnest
+    crowsnestInstance.SetChandler(chandlerInstance)
+    
+    log.Println("Chandler module initialized and ready to manage upstream connections")
+}
+```
+
+### Module Dependencies
+
+- **Required**: `config_manager` for configuration
+- **Required**: `tollwallet` for payment creation and token management
+- **Required**: `crowsnest` interface for upstream discovery notifications
+- **External**: `nostr` for event creation and validation
+
+## Implementation Details
+
+### Payment Event Creation
+
+```go
+func (c *Chandler) createPaymentEvent(proposal *PaymentProposal, macAddressSelf string) (*nostr.Event, error) {
+    // Get customer identity (could be random for privacy)
+    customerIdentity := c.getCustomerIdentity()
+    
+    // Create payment token from tollwallet
+    paymentAmount := proposal.Steps * proposal.PricingOption.PricePerStep
+    paymentToken, err := c.tollwallet.CreatePaymentToken(
+        proposal.PricingOption.MintURL,
+        paymentAmount,
+    )
+    if err != nil {
+        return nil, fmt.Errorf("failed to create payment token: %w", err)
+    }
+    
+    // Create payment event
+    paymentEvent := nostr.Event{
+        Kind: 21000,
+        Tags: nostr.Tags{
+            {"p", proposal.UpstreamPubkey},
+            {"device-identifier", "mac", macAddressSelf},
+            {"payment", paymentToken},
+        },
+        Content: "",
+    }
+    
+    // Sign with customer identity
+    err = paymentEvent.Sign(customerIdentity.PrivateKey)
+    if err != nil {
+        return nil, fmt.Errorf("failed to sign payment event: %w", err)
+    }
+    
+    return &paymentEvent, nil
+}
+```
+
+### Advertisement Comparison
+
+```go
+func (c *Chandler) checkAdvertisementChanges(session *ChandlerSession, newAd *nostr.Event) {
+    if session.Advertisement == nil {
+        return // First advertisement
+    }
+    
+    oldPricing := c.extractPricingOptions(session.Advertisement)
+    newPricing := c.extractPricingOptions(newAd)
+    
+    // Compare pricing options
+    if !c.comparePricingOptions(oldPricing, newPricing) {
+        logger.WithFields(logrus.Fields{
+            "upstream_pubkey": session.UpstreamTollgate.Advertisement.PubKey,
+            "old_pricing":     oldPricing,
+            "new_pricing":     newPricing,
+        }).Warn("WARNING: Upstream advertisement pricing changed")
+    }
+    
+    // Update to new advertisement
+    session.Advertisement = newAd
+}
+```
+
+## Testing Strategy
+
+### Unit Tests
+
+1. **SessionManager Tests**
+   - Session creation and storage
+   - Session state management
+   - Session cleanup on disconnect
+
+2. **PaymentDecisionEngine Tests**
+   - Budget constraint checking
+   - Trust policy enforcement
+   - Pricing validation
+
+3. **UsageTracker Tests**
+   - Time-based tracking accuracy
+   - Data-based tracking accuracy
+   - Threshold callback triggering
+   - Multi-session handling
+
+4. **PaymentClient Tests**
+   - Payment event creation
+   - HTTP communication with upstream
+   - Session response handling
+
+### Integration Tests
+
+1. **End-to-End Flow**
+   - Complete discovery-to-payment flow
+   - Session renewal workflows
+   - Disconnection handling
+
+2. **Crowsnest Integration**
+   - HandleUpstreamTollgate integration
+   - HandleDisconnect integration
+   - Error propagation
+
+3. **Configuration Tests**
+   - Trust policy enforcement
+   - Budget limit enforcement
+   - Threshold configuration
+
+### Manual Testing
+
+1. **Real Network Scenarios**
+   - Connect to actual upstream TollGates
+   - Test with different pricing models
+   - Verify usage tracking accuracy
+
+2. **Edge Cases**
+   - Network disconnections during payment
+   - Advertisement changes mid-session
+   - Budget exhaustion scenarios
+
+## Performance Considerations
+
+### Resource Usage
+
+- **Memory**: Session storage scales linearly with active upstream connections
+- **CPU**: Minimal background processing for usage tracking
+- **Network**: Periodic usage monitoring and renewal payments
+
+### Scalability
+
+- **Concurrent Sessions**: Handle multiple upstream connections simultaneously
+- **Usage Tracking**: Efficient tracking with configurable precision
+- **Payment Processing**: Asynchronous payment handling
+
+### Monitoring
+
+- **Metrics**: Track session counts, payment success rates, usage accuracy
+- **Health Checks**: Monitor usage tracker health and payment connectivity
+- **Alerting**: Log critical failures for operational monitoring
+
+## Security Considerations
+
+### Payment Security
+
+- **Token Generation**: Use tollwallet for secure token creation
+- **Event Signing**: Always sign payment events with customer identity
+- **Private Key Handling**: Never log or expose private keys
+
+### Trust Management
+
+- **Pubkey Verification**: Always verify upstream advertisement signatures
+- **Trust Policies**: Enforce configured allowlist/blocklist policies
+- **Advertisement Validation**: Validate all advertisement content and structure
+
+### Budget Protection
+
+- **Price Validation**: Always check pricing against configured maximums
+- **Spending Tracking**: Track all payments and enforce limits
+- **Session Limits**: Prevent excessive concurrent sessions
+
+## Future Enhancements
+
+### Planned Features
+
+1. **Advanced Budget Management**
+   - Time-based budget limits (hourly, daily, weekly)
+   - Per-upstream spending limits
+   - Spending analytics and reporting
+
+2. **Enhanced Trust System**
+   - Reputation tracking based on session success
+   - Dynamic trust adjustments
+   - Community trust feeds
+
+3. **Smart Renewal Strategies**
+   - Predictive renewal based on usage patterns
+   - Dynamic step sizing for renewals
+   - Cost optimization algorithms
+
+4. **Metrics and Analytics**
+   - Prometheus metrics integration
+   - Session analytics dashboard
+   - Cost-effectiveness reporting
+
+### Technical Debt
+
+- Consider using dependency injection for better testability
+- Implement proper graceful shutdown for usage trackers
+- Add comprehensive error recovery mechanisms
+- Consider using structured logging library consistently
+
+## Implementation Notes
+
+1. **Module Structure**: Follow existing TollGate module patterns with separate `go.mod` file
+2. **Dependencies**: Integrate with existing `tollwallet` and `config_manager` modules
+3. **Configuration**: Add chandler configuration to main config structure
+4. **Testing**: Implement comprehensive test coverage before integration
+5. **Documentation**: Maintain both technical and operational documentation
+
+## Conclusion
+
+The Chandler module provides intelligent upstream connection management for TollGate devices, handling the complete lifecycle from discovery to session management. By separating financial decision-making from network discovery, it creates a clean separation of concerns while enabling sophisticated payment and usage tracking capabilities.
+
+The design emphasizes simplicity in budget management while providing the flexibility needed for various upstream pricing models and usage patterns. The usage tracking system enables efficient automatic renewals while maintaining transparency in spending and usage.
+
+This design provides a solid foundation for implementing the Chandler module while maintaining consistency with the existing TollGate architecture and design principles. The focus on security, reliability, and maintainability ensures that the module can handle real-world upstream connection scenarios effectively.
\ No newline at end of file
diff --git a/docs/crowsnest-functional-design.md b/docs/crowsnest-functional-design.md
new file mode 100644
index 0000000..7eadf1c
--- /dev/null
+++ b/docs/crowsnest-functional-design.md
@@ -0,0 +1,489 @@
+# Crowsnest Module - Functional Design Document
+
+## Overview
+
+The Crowsnest module is responsible for monitoring network changes and detecting upstream TollGate devices. It watches for new network interfaces using netlink sockets, validates discovered TollGate advertisements, and hands off validated upstream TollGate information to the Chandler module for management.
+
+## Responsibilities
+
+- Monitor network interface changes using netlink sockets
+- Detect new network connections and disconnections
+- Probe discovered gateways for TollGate advertisements on port 2121
+- Validate TollGate advertisement format and signatures
+- Create `upstreamTollgate` objects for validated discoveries
+- Hand off upstream TollGate management to the Chandler module
+- Notify Chandler of network disconnections
+
+## Architecture
+
+### Core Components
+
+#### 1. NetworkMonitor
+- **Purpose**: Listen for netlink socket events to detect network changes
+- **Implementation**: Uses `github.com/vishvananda/netlink` package
+- **Events**: Interface up/down, route changes, address changes
+
+#### 2. TollGateProber
+- **Purpose**: Probe discovered gateways for TollGate advertisements
+- **Implementation**: HTTP client with timeout controls
+- **Protocol**: HTTP GET request to `http://<gateway_ip>:2121/`
+
+#### 3. AdvertisementValidator
+- **Purpose**: Validate TollGate advertisement as signed Nostr event
+- **Implementation**: Nostr event validation using `github.com/nbd-wtf/go-nostr`
+- **Validation**: Event structure, signature verification, kind 10021 check
+
+#### 4. DiscoveryTracker
+- **Purpose**: Track discovery attempts and prevent duplicate processing
+- **Implementation**: In-memory map with cleanup routines
+- **State**: Track interfaces being processed and recent discoveries
+
+## Data Structures
+
+### UpstreamTollgate
+```go
+type UpstreamTollgate struct {
+    // Network interface information
+    InterfaceName string    // e.g., "eth0", "wlan0"
+    MacAddress    string    // MAC address of local interface
+    GatewayIP     string    // IP address of the upstream gateway
+    
+    // TollGate advertisement information
+    Advertisement *nostr.Event // Complete TollGate advertisement event (kind 10021)
+    
+    // Discovery metadata
+    DiscoveredAt time.Time     // When this TollGate was discovered
+}
+```
+
+### NetworkEvent
+```go
+type NetworkEvent struct {
+    Type          EventType
+    InterfaceName string
+    InterfaceInfo *InterfaceInfo
+    GatewayIP     string
+    Timestamp     time.Time
+}
+
+type EventType int
+
+const (
+    EventInterfaceUp EventType = iota
+    EventInterfaceDown
+    EventRouteDeleted
+    EventAddressAdded
+    EventAddressDeleted
+)
+
+type InterfaceInfo struct {
+    Name         string
+    MacAddress   string
+    IPAddresses  []string
+    IsUp         bool
+    IsLoopback   bool
+    IsPointToPoint bool
+}
+```
+
+## Core Interfaces
+
+### Crowsnest Interface
+```go
+type Crowsnest interface {
+    Start() error
+    Stop() error
+    SetChandler(chandler ChandlerInterface)
+}
+```
+
+### ChandlerInterface (External Module)
+```go
+type ChandlerInterface interface {
+    // Called when a new upstream TollGate is discovered and validated
+    HandleUpstreamTollgate(upstream *UpstreamTollgate) error
+    
+    // Called when a network interface goes down
+    HandleDisconnect(interfaceName string) error
+}
+```
+
+## Workflow
+
+### Network Discovery Workflow
+
+```mermaid
+graph TD
+    A[Start Netlink Monitoring] --> B[Network Event Detected]
+    B --> C{Event Type}
+    C -->|Interface Up| D[Extract Interface Info]
+    C -->|Interface Down| E[Handle Disconnect]
+    C -->|Route Change| F[Check Gateway Changes]
+    
+    D --> G[Get Gateway IP]
+    G --> H[Probe Gateway:2121]
+    H --> I{Response?}
+    I -->|Yes| J[Validate Advertisement]
+    I -->|No| K[Log Non-TollGate Network]
+    
+    J --> L{Valid?}
+    L -->|Yes| M[Create UpstreamTollgate]
+    L -->|No| N[Log Invalid Advertisement]
+    
+    M --> O[chandler.HandleUpstreamTollgate]
+    O --> P[Log Success]
+    
+    E --> Q[chandler.HandleDisconnect]
+    Q --> R[Log Disconnect]
+    
+    F --> G
+    K --> S[Continue Monitoring]
+    N --> S
+    P --> S
+    R --> S
+```
+
+### Advertisement Validation Workflow
+
+```mermaid
+graph TD
+    A[Receive Advertisement] --> B[Parse JSON]
+    B --> C{Valid JSON?}
+    C -->|No| D[Return Invalid]
+    C -->|Yes| E[Parse Nostr Event]
+    
+    E --> F{Valid Event Structure?}
+    F -->|No| D
+    F -->|Yes| G[Verify Signature]
+    
+    G --> H{Valid Signature?}
+    H -->|No| D
+    H -->|Yes| I[Check Event Kind]
+    
+    I --> J{Kind 10021?}
+    J -->|No| D
+    J -->|Yes| K[Return Valid]
+```
+
+## Error Handling
+
+### Error Categories
+
+1. **Network Errors**
+   - Netlink socket failures
+   - Interface enumeration errors
+   - Gateway discovery failures
+
+2. **Communication Errors**
+   - HTTP request timeouts
+   - Connection refused
+   - Invalid response format
+
+3. **Validation Errors**
+   - Invalid Nostr event format
+   - Signature verification failures
+   - Invalid event kind (not 10021)
+
+4. **Integration Errors**
+   - Chandler interface failures
+   - Callback errors
+
+### Error Handling Strategy
+
+```go
+type CrowsnestError struct {
+    Type    ErrorType
+    Code    string
+    Message string
+    Cause   error
+    Context map[string]interface{}
+}
+
+type ErrorType int
+
+const (
+    ErrorTypeNetwork ErrorType = iota
+    ErrorTypeCommunication
+    ErrorTypeValidation
+    ErrorTypeIntegration
+)
+```
+
+### Logging Strategy
+
+- **Level**: Use standard log levels (DEBUG, INFO, WARN, ERROR)
+- **Format**: Structured logging with consistent fields
+- **Context**: Include interface name, IP addresses, and timestamps
+- **Sensitive Data**: Never log private keys or tokens
+
+#### Example Log Messages
+
+```go
+// Network discovery
+log.Printf("Network interface %s detected, gateway: %s", interfaceName, gatewayIP)
+
+// TollGate discovery
+log.Printf("TollGate advertisement found on %s (gateway: %s, pubkey: %s)", interfaceName, gatewayIP, advertisement.PubKey)
+
+// Validation failure
+log.Printf("Invalid TollGate advertisement on %s: %s", interfaceName, validationError)
+
+// Successful handoff
+log.Printf("Upstream TollGate handed off to chandler: %s", interfaceName)
+
+// Disconnection
+log.Printf("Network interface %s disconnected, notifying chandler", interfaceName)
+```
+
+## Configuration
+
+### Configuration Structure
+```go
+type CrowsnestConfig struct {
+    // Network monitoring settings
+    MonitoringInterval time.Duration `json:"monitoring_interval"`
+    
+    // Probing settings
+    ProbeTimeout       time.Duration `json:"probe_timeout"`
+    ProbeRetryCount    int           `json:"probe_retry_count"`
+    ProbeRetryDelay    time.Duration `json:"probe_retry_delay"`
+    
+    // Validation settings
+    RequireValidSignature bool `json:"require_valid_signature"`
+    
+    // Logging settings
+    LogLevel string `json:"log_level"`
+    
+    // Interface filtering
+    IgnoreInterfaces []string `json:"ignore_interfaces"`
+    OnlyInterfaces   []string `json:"only_interfaces"`
+    
+    // Discovery deduplication
+    DiscoveryTimeout time.Duration `json:"discovery_timeout"`
+}
+```
+
+### Default Configuration
+```json
+{
+    "monitoring_interval": "5s",
+    "probe_timeout": "10s",
+    "probe_retry_count": 3,
+    "probe_retry_delay": "2s",
+    "require_valid_signature": true,
+    "log_level": "INFO",
+    "ignore_interfaces": ["lo", "docker0"],
+    "only_interfaces": [],
+    "discovery_timeout": "300s"
+}
+```
+
+## Integration Points
+
+### Main Application Integration
+
+```go
+// In main.go init() function
+func initCrowsnest() {
+    crowsnestInstance, err := crowsnest.NewCrowsnest(configManager)
+    if err != nil {
+        log.Fatalf("Failed to create crowsnest instance: %v", err)
+    }
+    
+    // Set chandler when available
+    // crowsnestInstance.SetChandler(chandlerInstance)
+    
+    go crowsnestInstance.Start()
+    log.Println("Crowsnest module initialized and monitoring network changes")
+}
+```
+
+### Module Dependencies
+
+- **Required**: `config_manager` for configuration
+- **Required**: `chandler` interface for upstream TollGate handoff
+- **External**: `netlink` for network monitoring, `nostr` for event validation
+
+## Chandler Interface Specifications
+
+### Purpose
+The Chandler module is responsible for managing upstream TollGate connections after they have been discovered and validated by the Crowsnest module.
+
+### Interface Contract
+
+```go
+type ChandlerInterface interface {
+    // HandleUpstreamTollgate is called when Crowsnest discovers a new upstream TollGate
+    // The chandler should:
+    // - Store the upstream TollGate information
+    // - Establish connection management
+    // - Handle session management with the upstream TollGate
+    // - Return error if the upstream TollGate cannot be handled
+    HandleUpstreamTollgate(upstream *UpstreamTollgate) error
+    
+    // HandleDisconnect is called when a network interface goes down
+    // The chandler should:
+    // - Clean up any sessions or connections for this interface
+    // - Release any resources associated with this interface
+    // - Update connection state tracking
+    HandleDisconnect(interfaceName string) error
+}
+```
+
+### Expected Chandler Behavior
+
+1. **On HandleUpstreamTollgate**:
+   - Validate the upstream TollGate information
+   - Store connection metadata
+   - Initialize session management
+   - Begin connection health monitoring
+   - Return error if unable to handle the upstream TollGate
+
+2. **On HandleDisconnect**:
+   - Identify all sessions associated with the interface
+   - Clean up connection state
+   - Release allocated resources
+   - Update tracking state
+   - Return error if cleanup fails
+
+### Error Handling Contract
+
+- **HandleUpstreamTollgate**: Return error if unable to manage the upstream TollGate
+- **HandleDisconnect**: Return error if cleanup fails (non-critical)
+- **Logging**: Chandler should log its own operations, Crowsnest will log handoff attempts
+
+## Testing Strategy
+
+### Unit Tests
+
+1. **NetworkMonitor Tests**
+   - Mock netlink events
+   - Test interface detection
+   - Test event filtering
+
+2. **TollGateProber Tests**
+   - Mock HTTP responses
+   - Test timeout handling
+   - Test retry logic
+
+3. **AdvertisementValidator Tests**
+   - Test valid advertisements (kind 10021)
+   - Test invalid signatures
+   - Test wrong event kinds
+
+4. **DiscoveryTracker Tests**
+   - Test deduplication logic
+   - Test cleanup routines
+   - Test thread safety
+
+### Integration Tests
+
+1. **End-to-End Discovery**
+   - Mock network interface changes
+   - Verify complete discovery workflow
+   - Test chandler integration
+
+2. **Chandler Integration**
+   - Mock chandler interface
+   - Test successful handoffs
+   - Test error handling
+
+3. **Error Scenarios**
+   - Network failures
+   - Invalid advertisements
+   - Chandler failures
+   - Timeout conditions
+
+### Manual Testing
+
+1. **Real Network Changes**
+   - Connect/disconnect network interfaces
+   - Verify detection and chandler notification
+   - Test with actual TollGate devices
+
+## Performance Considerations
+
+### Resource Usage
+
+- **Memory**: Minimal, only tracking active discoveries
+- **CPU**: Minimal background processing
+- **Network**: Periodic probing with configurable intervals
+
+### Scalability
+
+- **Concurrent Interfaces**: Handle multiple network interfaces
+- **Rate Limiting**: Prevent overwhelming upstream TollGates
+- **Deduplication**: Prevent duplicate discovery attempts
+
+### Monitoring
+
+- **Metrics**: Track discovery rates, validation failures, handoff success
+- **Health Checks**: Monitor netlink socket health
+- **Alerting**: Log critical failures for operational monitoring
+
+## Security Considerations
+
+### Advertisement Validation
+
+- **Signature Verification**: Always verify Nostr event signatures
+- **Content Validation**: Validate all required tags and formats
+- **Replay Protection**: Consider event timestamps for freshness
+
+### Network Security
+
+- **Timeout Controls**: Prevent hanging connections
+- **Rate Limiting**: Prevent excessive probing
+- **Interface Filtering**: Only monitor intended interfaces
+
+### Information Disclosure
+
+- **Logging**: Avoid logging sensitive network information
+- **Error Messages**: Provide minimal information in error responses
+- **Handoff Security**: Ensure secure data transfer to chandler
+
+## Future Enhancements
+
+### Planned Features
+
+1. **Advanced Filtering**
+   - Network type filtering (WiFi, Ethernet, etc.)
+   - Gateway address filtering
+   - Custom validation rules
+
+2. **Enhanced Discovery**
+   - Parallel discovery for multiple interfaces
+   - Background re-discovery for failed attempts
+   - Discovery result caching
+
+3. **Metrics and Monitoring**
+   - Prometheus metrics integration
+   - Discovery success rates
+   - Handoff performance metrics
+
+4. **Configuration Management**
+   - Dynamic configuration updates
+   - Per-interface configuration
+   - Remote configuration support
+
+### Technical Debt
+
+- Consider using dependency injection for better testability
+- Implement proper graceful shutdown handling
+- Add comprehensive error recovery mechanisms
+- Consider using structured logging library
+
+## Implementation Notes
+
+1. **Module Structure**: Follow existing TollGate module patterns with separate `go.mod` file
+2. **Dependencies**: Minimize external dependencies, prefer standard library where possible
+3. **Configuration**: Integrate with existing `config_manager` for consistency
+4. **Testing**: Implement comprehensive test coverage before integration
+5. **Documentation**: Maintain both technical and operational documentation
+
+## Conclusion
+
+The Crowsnest module provides a focused, single-responsibility component for network monitoring and upstream TollGate discovery. By cleanly separating discovery from management, it creates a clear interface with the Chandler module while maintaining the robustness required for reliable network monitoring.
+
+The design emphasizes security, reliability, and maintainability, following the established patterns in the TollGate codebase. The clear separation of concerns between discovery (Crowsnest) and management (Chandler) ensures that each module can be developed, tested, and maintained independently.
+
+This design provides a solid foundation for implementing the Crowsnest module while maintaining consistency with the existing TollGate architecture and design principles.
\ No newline at end of file
diff --git a/reference-material/protocol/01.md b/reference-material/protocol/01.md
new file mode 100644
index 0000000..cf9c253
--- /dev/null
+++ b/reference-material/protocol/01.md
@@ -0,0 +1,149 @@
+# TIP-01 - Base Events
+`draft` `mandatory` `kind=10021` `kind=21000` `kind=1022`
+
+---
+## TollGate Discovery
+Tollgate Details / Advertisement is expressed through the following Nostr event
+```json
+{
+    "kind": 10021,
+    "pubkey": "24d6...3662", // TollGate identity
+    // ...
+    "tags": [
+        ["metric", "<value>"],
+        ["step_size", "<value>"],
+        ["tips", "1", "2", "5", "..."]
+    ]
+}
+```
+
+Tags:
+- `metric`: `milliseconds` or `bytes`
+- `min_steps`: (Optional) positive whole number. Defines a minimum amount of steps a customer must purchase at a time.
+- `tips`: List of implemented TollGate TIP's represented as numbers
+
+### Example
+```json
+{
+    "kind": 10021,
+    "pubkey": "24d6...3662",
+    // ...
+    "tags": [
+        ["metric", "milliseconds"],
+        ["step_size", "60000"], // 1 minute step size
+        ["step_purchase_limits", "1", "0"], // Min 1 minute, max infinite minutes
+        ["tips", "1", "2", "5", "..."]
+    ]
+}
+```
+
+## Payment
+```json
+{
+	"kind": 21000,
+	"pubkey": "63gy...9xvq", // Customer Identity, Can be randomly generated
+	// ...
+	"tags": [
+		["p", "24d6...3662"], // TollGate identity (pubkey)
+		["device-identifier", "<type>", "<value>"],
+		["payment", "<bearer_asset>"]
+	]
+}
+```
+
+Tags:
+- `p`: pubkey of the TollGate (from the TollGate Details event) who takes the payment
+- `device-identifier`: (hardware) identifier of the customer's device. Second argument specifies type of identifier, third argument is the identifier value. `["device-identifier", "mac", "00:1A:2B:3C:4D:5E"]`
+- `payment`: Bearer asset, such as Cashu token `["payment", "cashuB..."]`
+
+
+## Session
+```json
+{
+	"kind": 1022,
+	"pubkey": "63gy...9xvq", // TollGate identity
+	// ...
+	"tags": [
+		["p", "6hjq...1fi6"], // Customer identity (pubkey)
+		["device-identifier", "<type>", "<value>"],
+		["allotment", "<amount>"]
+		["metric", "<metric>"]
+	]
+}
+```
+
+Tags:
+- `p`: pubkey of the TollCustomer Gate (from the Customer's Payment event)
+- `device-identifier`: (hardware) identifier of the customer's device.
+- `allotment`: Amount of `<metric>` allotted to customer after payment.
+- `metric`: The purchased metric
+
+## Notice Events
+
+Notice events are used by TollGates to communicate issues, warnings, and informational messages to customers. These events provide structured error reporting and debugging information.
+
+```json
+{
+    "kind": 21023,
+    "pubkey": "<tollgate_pubkey>",
+    "tags": [
+        ["p", "customer_pubkey"], // Optional - only when addressing specific customer
+        ["level", "<error|warning|info|debug>"],
+        ["code", "<text-code>"]
+    ],
+    "content": "Human-readable message",
+    // ...
+}
+```
+
+### Tags
+
+#### Required Tags
+- `level`: Severity level of the notice
+  - `error`: Critical errors preventing operation
+  - `warning`: Non-critical issues that may affect experience
+  - `info`: Informational messages
+  - `debug`: Debug information for troubleshooting, should not be used in production settings.
+
+- `code`: Machine-readable error code for programmatic handling. Examples:
+  - `session-error`: Session creation or management error
+  - `upstream-error-not-connected`: TollGate has no upstream connection
+  - `payment-error-mint-not-accepted`: Payment from unsupported mint
+  - `payment-error-token-spent`: Cashu token already spent
+
+#### Optional Tags
+- `p`: Customer pubkey when addressing a specific customer. Omitted for general notices.
+
+### Content
+Human-readable message describing the issue or information. Should be user-friendly and provide actionable guidance when possible.
+
+### Examples
+
+#### No Upstream Error
+```json
+{
+    "kind": 21023,
+    "pubkey": "24d6...3662",
+    "tags": [
+        ["level", "error"],
+        ["code", "upstream-error-not-connected"]
+    ],
+    "content": "TollGate Currently has no upstream connection.",
+    // ...
+}
+```
+
+#### Payment Error
+```json
+{
+    "kind": 21023,
+    "pubkey": "24d6...3662",
+    "tags": [
+        ["p", "63gy...9xvq"],
+        ["level", "error"],
+        ["code", "payment-error-token-spent"]
+    ],
+    "content": "Payment processing failed: Token already spent",
+    // ...
+}
+```
\ No newline at end of file
diff --git a/reference-material/protocol/02.md b/reference-material/protocol/02.md
new file mode 100644
index 0000000..a6a1059
--- /dev/null
+++ b/reference-material/protocol/02.md
@@ -0,0 +1,64 @@
+# TIP-02 - Cashu payments
+`draft` `mandatory` `kind=10021` `kind=21000` `kind=1022`
+
+---
+
+- A TollGate can accept multiple mints and multiple currencies.
+
+## TollGate Discovery
+
+A TollGate that accepts Cashu tokens as payment may advertise its pricing using the following tags.
+
+```json
+{
+    "kind": 10021,
+    // ...
+    "tags": [
+        // <TIP-01 tags>
+        ["price_per_step", "<bearer_asset_type>", "<price>", "<unit>", "<mint_url>", "<min_steps>"],
+        ["price_per_step", "...", "...", "...", "...", "..."],
+    ]
+}
+```
+
+Tags:
+- `price_per_step`: (one or more)
+	- `<bearer_asset_type>` Always `cashu`.
+	- `<price>` price for purchasing 1 time the `step_size`.
+	- `<unit>` unit or currency.
+	- `<mint_url>` Accepted mint. Example: 210 sats per minute (60000ms)
+	- `<min_steps>` Minimum amount of steps to purchase using this mint. Positive whole number, default 0 ⚠️ TENTATIVE: Strucuture of incorporation of fees/min purchases is not final
+
+- The value of `<price>` MUST be the same across all occurrences of the same `<unit>` value.
+
+### Example
+```json
+{
+    "kind": 10021,
+    // ...
+    "tags": [
+        // <TIP-01 tags>
+        ["price_per_step", "cashu", "210", "sat", "https://mint.domain.net", 1],
+        ["price_per_step", "cashu", "210", "sat", "https://other.mint.net", 1],
+        ["price_per_step", "cashu", "500", "eur", "https://mint.thirddomain.eu", 3],
+    ]
+}
+```
+
+## Payment
+
+When the customer pays an exact multiple of `<price_per_step>` and adds `<mint_fee>`. The TolGate MUST allot at least that amount of steps to the customer.
+
+```json
+{
+	"kind": 21000,
+	// ...
+	"tags": [
+		// <TIP-01 tags>
+		["payment", "cashuB..."]
+	]
+}
+```
+
+Tags:
+- `payment`: Cashu Token
diff --git a/reference-material/protocol/03.md b/reference-material/protocol/03.md
new file mode 100644
index 0000000..c730b38
--- /dev/null
+++ b/reference-material/protocol/03.md
@@ -0,0 +1,69 @@
+# TIP-03 - Http server
+`draft` `optional` `kind=21000` `kind=1022` `kind=10021`
+
+---
+
+Minimal setup for allowing payments on LAN networks. Default port `2121`
+
+## POST /
+The Server MUST take a http `POST` request containing a valid [Payment](#payment) event in the request body.
+
+If the TollGate accepts the provided payment it MUST return http `200 OK` response where the body is a `kind=1022` TollGate Session event.
+
+If the payment is invalid, it MAY return a http `402 Payment Required` status.
+
+### CURL Request Example (Successful Payment):
+
+```bash
+curl -X POST http://192.168.1.1:2121/ # TollGate IP
+  -H "Content-Type: application/json" \
+  -d '{
+    "kind": 21000,
+    ...
+  }'
+```
+
+### Response Example (Successful Payment):
+
+```
+HTTP/1.1 200 OK
+Content-Type: application/json
+Content-Length: 456
+
+{
+  "kind": 1022,
+  ...
+}
+```
+
+### Response Example (Invalid Payment):
+
+```
+HTTP/1.1 402 Payment Required
+Content-Type: text/plain
+Content-Length: 15
+
+This mint is not accepted
+```
+
+## GET /
+A `GET` request on the root endpoint MAY return http `200 OK` response where the  body is a `kind=10021` TollGate Discovery event.
+
+### CURL Request Example:
+
+```bash
+curl -X GET http://192.168.1.1:2121/ # TollGate IP
+```
+
+### Response Example:
+
+```
+HTTP/1.1 200 OK
+Content-Type: application/json
+Content-Length: 398
+
+{
+  "kind": 10021,
+  ...
+}
+```
\ No newline at end of file
diff --git a/reference-material/protocol/04.md b/reference-material/protocol/04.md
new file mode 100644
index 0000000..64caba6
--- /dev/null
+++ b/reference-material/protocol/04.md
@@ -0,0 +1,27 @@
+# TIP-04 - Restrictive OS compatibility
+`draft` `optional` `kind=21000`
+
+---
+
+## GET /whoami
+A `GET` request on the `/whoami` endpoint MUST return http status `200 OK` with the body containing the customer's `<device-identifier>` that the customer MUST include in their payment event.
+
+http port MUST be the same as [TIP-03](./03.md)
+
+Formatted as `[type]=[value]`
+
+### CURL Request Example:
+
+```bash
+curl -X GET http://192.168.1.1:2121/whoami # TollGate IP
+```
+
+### Response Example:
+
+```
+HTTP/1.1 200 OK
+Content-Type: text/plain
+Content-Length: 20
+
+mac=00:1A:2B:3C:4D:5E
+```
diff --git a/reference-material/protocol/05.md b/reference-material/protocol/05.md
new file mode 100644
index 0000000..e71479e
--- /dev/null
+++ b/reference-material/protocol/05.md
@@ -0,0 +1,6 @@
+# TIP-05 - Encrypted Events
+`draft` `optional`
+
+---
+
+- RESERVED: Encrypt Nostr events for privacy / security
\ No newline at end of file
diff --git a/reference-material/protocol/06.md b/reference-material/protocol/06.md
new file mode 100644
index 0000000..2d4eed0
--- /dev/null
+++ b/reference-material/protocol/06.md
@@ -0,0 +1,7 @@
+# TIP-06 - Nostr Relay
+`draft` `optional`
+
+---
+
+- RESERVED: Nostr relay 
+    - MUST be exposed on port `:4242`
\ No newline at end of file
diff --git a/reference-material/protocol/10.md b/reference-material/protocol/10.md
new file mode 100644
index 0000000..5d5b354
--- /dev/null
+++ b/reference-material/protocol/10.md
@@ -0,0 +1,6 @@
+# TIP-10 - Beacon Frame Advertisement
+`draft` `optional`
+
+---
+- RESERVED: advertise tollgate in WIFI beaconframe
+
diff --git a/reference-material/protocol/README.md b/reference-material/protocol/README.md
new file mode 100644
index 0000000..ee6eb31
--- /dev/null
+++ b/reference-material/protocol/README.md
@@ -0,0 +1,32 @@
+# TIPs
+
+TIPs stand for **TollGate Implementation Possibilities**.
+
+They exist to document what may be implemented by TollGate compatible devices.
+
+---
+
+- [List](#list)
+- [License](#license)
+
+---
+
+## List
+
+- [TIP-01: Base Events](01.md)
+- [TIP-02: Cashu payments](02.md)
+- [TIP-03: Http server](03.md)
+- [TIP-04: Restrictive OS compatibility](04.md)
+- [TIP-05: Encrypted events](05.md)
+- [TIP-06: Nostr relay](06.md)
+- [TIP-10: Beacon Frame Advertisement](10.md)
+
+## Breaking changes
+| When | What |
+|------|------|
+| June 2025 | Cashu payments mint now is added to `<price_per_step>` tag, removing `<mint>` tag |
+| June 2025 | Changed Discovery to no longer be ephemeral |
+
+## License
+
+All TIPs are public domain.
\ No newline at end of file
diff --git a/src/chandler/chandler.go b/src/chandler/chandler.go
new file mode 100644
index 0000000..233f46f
--- /dev/null
+++ b/src/chandler/chandler.go
@@ -0,0 +1,800 @@
+package chandler
+
+import (
+	"bytes"
+	"encoding/json"
+	"fmt"
+	"io"
+	"net/http"
+	"strconv"
+	"sync"
+	"time"
+
+	"github.com/OpenTollGate/tollgate-module-basic-go/src/config_manager"
+	"github.com/OpenTollGate/tollgate-module-basic-go/src/merchant"
+	"github.com/OpenTollGate/tollgate-module-basic-go/src/tollgate_protocol"
+	"github.com/nbd-wtf/go-nostr"
+	"github.com/sirupsen/logrus"
+)
+
+// Module-level logger with pre-configured module field
+var logger = logrus.WithField("module", "chandler")
+
+// Chandler is the main implementation of ChandlerInterface
+type Chandler struct {
+	configManager *config_manager.ConfigManager
+	merchant      merchant.MerchantInterface
+	sessions      map[string]*ChandlerSession // keyed by upstream pubkey
+	mu            sync.RWMutex
+}
+
+// NewChandler creates a new chandler instance
+func NewChandler(configManager *config_manager.ConfigManager, merchantImpl merchant.MerchantInterface) (ChandlerInterface, error) {
+	config := configManager.GetConfig()
+	if config == nil {
+		return nil, fmt.Errorf("config is nil")
+	}
+
+	chandler := &Chandler{
+		configManager: configManager,
+		merchant:      merchantImpl,
+		sessions:      make(map[string]*ChandlerSession),
+	}
+
+	logger.Info("Chandler initialized successfully")
+	return chandler, nil
+}
+
+// HandleUpstreamTollgate handles a discovered upstream TollGate
+func (c *Chandler) HandleUpstreamTollgate(upstream *UpstreamTollgate) error {
+	logger.WithFields(logrus.Fields{
+		"upstream_pubkey": upstream.Advertisement.PubKey,
+		"interface":       upstream.InterfaceName,
+		"gateway":         upstream.GatewayIP,
+		"mac_address":     upstream.MacAddress,
+		"discovered_at":   upstream.DiscoveredAt.Format(time.RFC3339),
+	}).Info("🔗 CONNECTED: Processing upstream TollGate connection")
+
+	// Extract advertisement information
+	adInfo, err := tollgate_protocol.ExtractAdvertisementInfo(upstream.Advertisement)
+	if err != nil {
+		logger.WithFields(logrus.Fields{
+			"upstream_pubkey": upstream.Advertisement.PubKey,
+			"error":           err,
+		}).Error("Failed to extract advertisement information")
+		return err
+	}
+
+	// Check trust policy
+	config := c.configManager.GetConfig()
+	err = ValidateTrustPolicy(
+		upstream.Advertisement.PubKey,
+		config.Chandler.Trust.Allowlist,
+		config.Chandler.Trust.Blocklist,
+		config.Chandler.Trust.DefaultPolicy,
+	)
+	if err != nil {
+		logger.WithFields(logrus.Fields{
+			"upstream_pubkey": upstream.Advertisement.PubKey,
+			"error":           err,
+		}).Warn("Trust policy validation failed")
+		return err
+	}
+
+	// Find overlapping mint options and select the best one
+	selectedPricing, err := c.selectCompatiblePricingOption(adInfo.PricingOptions)
+	if err != nil {
+		logger.WithFields(logrus.Fields{
+			"upstream_pubkey": upstream.Advertisement.PubKey,
+			"error":           err,
+		}).Error("No compatible pricing options found")
+		return err
+	}
+
+	// Check if we have sufficient funds for minimum purchase
+	minPaymentAmount := selectedPricing.MinSteps * selectedPricing.PricePerStep
+	availableBalance := c.merchant.GetBalanceByMint(selectedPricing.MintURL)
+
+	if availableBalance < minPaymentAmount {
+		err := fmt.Errorf("insufficient funds: need %d sats, have %d sats", minPaymentAmount, availableBalance)
+		logger.WithFields(logrus.Fields{
+			"upstream_pubkey":   upstream.Advertisement.PubKey,
+			"required_amount":   minPaymentAmount,
+			"available_balance": availableBalance,
+			"mint_url":          selectedPricing.MintURL,
+		}).Error("Insufficient funds for minimum purchase")
+		return err
+	}
+
+	// Calculate steps based on preferred session increments for granular payments
+	var preferredAllotment uint64
+	switch adInfo.Metric {
+	case "milliseconds":
+		preferredAllotment = config.Chandler.Sessions.PreferredSessionIncrementsMilliseconds
+	case "bytes":
+		preferredAllotment = config.Chandler.Sessions.PreferredSessionIncrementsBytes
+	default:
+		return fmt.Errorf("unsupported metric: %s", adInfo.Metric)
+	}
+
+	// Convert preferred allotment to steps
+	preferredSteps := preferredAllotment / adInfo.StepSize
+	if preferredSteps == 0 {
+		preferredSteps = 1 // Minimum 1 step
+	}
+
+	// Calculate affordability constraints
+	maxAffordableSteps := availableBalance / selectedPricing.PricePerStep
+
+	// Choose the smallest of: preferred, affordable, or minimum required
+	desiredSteps := preferredSteps
+
+	logger.WithFields(logrus.Fields{
+		"preferred_allotment":  preferredAllotment,
+		"step_size":            adInfo.StepSize,
+		"preferred_steps":      preferredSteps,
+		"available_balance":    availableBalance,
+		"price_per_step":       selectedPricing.PricePerStep,
+		"max_affordable_steps": maxAffordableSteps,
+		"min_steps":            selectedPricing.MinSteps,
+		"desired_steps_before": desiredSteps,
+	}).Info("🔍 Step calculation details")
+
+	if desiredSteps < selectedPricing.MinSteps {
+		desiredSteps = selectedPricing.MinSteps
+		logger.WithFields(logrus.Fields{
+			"adjusted_to_min": desiredSteps,
+		}).Info("🔍 Adjusted to minimum steps")
+	}
+	if desiredSteps > maxAffordableSteps {
+		desiredSteps = maxAffordableSteps
+		logger.WithFields(logrus.Fields{
+			"adjusted_to_affordable": desiredSteps,
+		}).Info("🔍 Adjusted to affordable steps")
+	}
+
+	steps := desiredSteps
+
+	logger.WithFields(logrus.Fields{
+		"metric":               adInfo.Metric,
+		"preferred_allotment":  preferredAllotment,
+		"preferred_steps":      preferredSteps,
+		"min_required_steps":   selectedPricing.MinSteps,
+		"max_affordable_steps": maxAffordableSteps,
+		"final_steps":          steps,
+		"step_size":            adInfo.StepSize,
+	}).Info("💳 Calculated payment steps for granular session")
+
+	// Final check: ensure we don't send a payment with 0 steps
+	if steps == 0 {
+		err := fmt.Errorf("cannot make payment with 0 steps: insufficient funds or invalid pricing")
+		logger.WithFields(logrus.Fields{
+			"upstream_pubkey":      upstream.Advertisement.PubKey,
+			"available_balance":    availableBalance,
+			"price_per_step":       selectedPricing.PricePerStep,
+			"max_affordable_steps": maxAffordableSteps,
+			"min_steps":            selectedPricing.MinSteps,
+		}).Error("Payment rejected: 0 steps calculated")
+		return err
+	}
+
+	// Create payment proposal
+	proposal := &PaymentProposal{
+		UpstreamPubkey:     upstream.Advertisement.PubKey,
+		Steps:              steps,
+		PricingOption:      selectedPricing,
+		Reason:             "initial",
+		EstimatedAllotment: CalculateAllotment(steps, adInfo.StepSize),
+	}
+
+	// Validate budget constraints
+	err = ValidateBudgetConstraints(
+		proposal,
+		config.Chandler.MaxPricePerMillisecond,
+		config.Chandler.MaxPricePerByte,
+		adInfo.Metric,
+		adInfo.StepSize,
+	)
+	if err != nil {
+		logger.WithFields(logrus.Fields{
+			"upstream_pubkey": upstream.Advertisement.PubKey,
+			"error":           err,
+		}).Warn("Budget constraints not met")
+		return err
+	}
+
+	// Generate unique customer private key for this session
+	customerPrivateKey := nostr.GeneratePrivateKey()
+	customerPublicKey, err := nostr.GetPublicKey(customerPrivateKey)
+	if err != nil {
+		logger.WithFields(logrus.Fields{
+			"upstream_pubkey": upstream.Advertisement.PubKey,
+			"error":           err,
+		}).Error("Failed to derive customer public key")
+		return err
+	}
+
+	// Create session first
+	session := &ChandlerSession{
+		UpstreamTollgate:   upstream,
+		CustomerPrivateKey: customerPrivateKey,
+		Advertisement:      upstream.Advertisement,
+		AdvertisementInfo:  adInfo,
+		SelectedPricing:    selectedPricing,
+		TotalAllotment:     proposal.EstimatedAllotment,
+		RenewalThresholds:  config.Chandler.Sessions.DefaultRenewalThresholds,
+		CreatedAt:          time.Now(),
+		LastPaymentAt:      time.Now(),
+		TotalSpent:         proposal.Steps * selectedPricing.PricePerStep,
+		PaymentCount:       1,
+		Status:             SessionActive,
+	}
+
+	// Create and send payment
+	// Log payment proposal details for debugging
+	logger.WithFields(logrus.Fields{
+		"upstream_pubkey":     proposal.UpstreamPubkey,
+		"steps":               proposal.Steps,
+		"price_per_step":      proposal.PricingOption.PricePerStep,
+		"mint_url":            proposal.PricingOption.MintURL,
+		"min_steps":           proposal.PricingOption.MinSteps,
+		"reason":              proposal.Reason,
+		"estimated_allotment": proposal.EstimatedAllotment,
+		"total_amount":        proposal.Steps * proposal.PricingOption.PricePerStep,
+	}).Info("💰 Creating payment proposal for upstream TollGate")
+
+	sessionEvent, err := c.createAndSendPayment(session, proposal)
+	if err != nil {
+		logger.WithFields(logrus.Fields{
+			"upstream_pubkey": upstream.Advertisement.PubKey,
+			"error":           err,
+		}).Error("Failed to create and send payment")
+		return err
+	}
+
+	// Extract actual allotment from session event response
+	actualAllotment, err := c.extractAllotment(sessionEvent)
+	if err != nil {
+		logger.WithFields(logrus.Fields{
+			"upstream_pubkey": upstream.Advertisement.PubKey,
+			"error":           err,
+		}).Error("Failed to extract allotment from session event")
+		return err
+	}
+
+	// Update session with the received session event and actual allotment
+	session.SessionEvent = sessionEvent
+	session.TotalAllotment = actualAllotment
+
+	// Create and start usage tracker
+	err = c.createUsageTracker(session)
+	if err != nil {
+		logger.WithFields(logrus.Fields{
+			"upstream_pubkey": upstream.Advertisement.PubKey,
+			"error":           err,
+		}).Error("Failed to create usage tracker")
+		return err
+	}
+
+	// Store session
+	c.mu.Lock()
+	c.sessions[upstream.Advertisement.PubKey] = session
+	c.mu.Unlock()
+
+	logger.WithFields(logrus.Fields{
+		"upstream_pubkey": upstream.Advertisement.PubKey,
+		"customer_pubkey": customerPublicKey,
+		"allotment":       session.TotalAllotment,
+		"metric":          adInfo.Metric,
+		"amount_spent":    session.TotalSpent,
+	}).Info("✅ CONNECTED: Session created successfully with upstream TollGate")
+
+	// Also log advertisement details
+	if upstream.Advertisement != nil {
+		logger.WithFields(logrus.Fields{
+			"interface":        upstream.InterfaceName,
+			"advertisement_id": upstream.Advertisement.ID,
+			"public_key":       upstream.Advertisement.PubKey,
+			"kind":             upstream.Advertisement.Kind,
+		}).Info("📡 TollGate advertisement details")
+	}
+
+	return nil
+}
+
+// HandleDisconnect handles network interface disconnection
+func (c *Chandler) HandleDisconnect(interfaceName string) error {
+	c.mu.Lock()
+	defer c.mu.Unlock()
+
+	var disconnectedSessions []string
+
+	// Find sessions on this interface
+	for pubkey, session := range c.sessions {
+		if session.UpstreamTollgate.InterfaceName == interfaceName {
+			// Stop usage tracker
+			if session.UsageTracker != nil {
+				session.UsageTracker.Stop()
+			}
+
+			// Mark session as disconnected
+			session.Status = SessionExpired
+			disconnectedSessions = append(disconnectedSessions, pubkey)
+
+			logger.WithFields(logrus.Fields{
+				"upstream_pubkey": pubkey,
+				"interface":       interfaceName,
+				"gateway":         session.UpstreamTollgate.GatewayIP,
+			}).Info("❌ DISCONNECTED: Session terminated due to interface disconnect")
+		}
+	}
+
+	// Remove disconnected sessions
+	for _, pubkey := range disconnectedSessions {
+		delete(c.sessions, pubkey)
+	}
+
+	if len(disconnectedSessions) > 0 {
+		logger.WithFields(logrus.Fields{
+			"interface":           interfaceName,
+			"terminated_sessions": len(disconnectedSessions),
+		}).Info("❌ DISCONNECTED: Interface disconnected, sessions cleaned up")
+	} else {
+		// Interface went down but we didn't have any TollGate connections
+		logger.WithField("interface", interfaceName).Info("⬇️ INTERFACE DOWN: Interface disconnected (no TollGate connections)")
+	}
+
+	return nil
+}
+
+// HandleUpcomingRenewal handles renewal threshold callbacks from usage trackers
+func (c *Chandler) HandleUpcomingRenewal(upstreamPubkey string, currentUsage uint64) error {
+	c.mu.RLock()
+	session, exists := c.sessions[upstreamPubkey]
+	c.mu.RUnlock()
+
+	if !exists {
+		return fmt.Errorf("session not found for pubkey: %s", upstreamPubkey)
+	}
+
+	logger.WithFields(logrus.Fields{
+		"upstream_pubkey": upstreamPubkey,
+		"current_usage":   currentUsage,
+		"total_allotment": session.TotalAllotment,
+	}).Info("Processing renewal request")
+
+	// Check if advertisement has changed
+	c.checkAdvertisementChanges(session)
+
+	// Create renewal proposal
+	config := c.configManager.GetConfig()
+	steps := config.Chandler.Sessions.PreferredSessionIncrementsMilliseconds / session.AdvertisementInfo.StepSize
+	if session.AdvertisementInfo.Metric == "bytes" {
+		steps = config.Chandler.Sessions.PreferredSessionIncrementsBytes / session.AdvertisementInfo.StepSize
+	}
+
+	proposal := &PaymentProposal{
+		UpstreamPubkey:     upstreamPubkey,
+		Steps:              steps,
+		PricingOption:      session.SelectedPricing,
+		Reason:             "renewal",
+		EstimatedAllotment: CalculateAllotment(steps, session.AdvertisementInfo.StepSize),
+	}
+
+	// Validate budget for renewal
+	err := ValidateBudgetConstraints(
+		proposal,
+		config.Chandler.MaxPricePerMillisecond,
+		config.Chandler.MaxPricePerByte,
+		session.AdvertisementInfo.Metric,
+		session.AdvertisementInfo.StepSize,
+	)
+	if err != nil {
+		logger.WithFields(logrus.Fields{
+			"upstream_pubkey": upstreamPubkey,
+			"error":           err,
+		}).Warn("Renewal budget constraints not met, pausing session")
+
+		session.mu.Lock()
+		session.Status = SessionPaused
+		session.UsageTracker.Stop()
+		session.mu.Unlock()
+
+		return err
+	}
+
+	// Send renewal payment
+	sessionEvent, err := c.createAndSendPayment(session, proposal)
+	if err != nil {
+		logger.WithFields(logrus.Fields{
+			"upstream_pubkey": upstreamPubkey,
+			"error":           err,
+		}).Error("Failed to send renewal payment")
+		return err
+	}
+
+	// Extract new allotment from session event response
+	newAllotment, err := c.extractAllotment(sessionEvent)
+	if err != nil {
+		logger.WithFields(logrus.Fields{
+			"upstream_pubkey": upstreamPubkey,
+			"error":           err,
+		}).Error("Failed to extract allotment from session event")
+		return err
+	}
+
+	// Update session
+	session.mu.Lock()
+	session.TotalAllotment = newAllotment
+	session.LastRenewalAt = time.Now()
+	session.LastPaymentAt = time.Now()
+	session.TotalSpent += proposal.Steps * proposal.PricingOption.PricePerStep
+	session.PaymentCount++
+
+	if session.UsageTracker != nil {
+		err := session.UsageTracker.SessionChanged(session)
+		if err != nil {
+			logger.WithFields(logrus.Fields{
+				"upstream_pubkey": upstreamPubkey,
+				"error":           err,
+			}).Error("Failed to update usage tracker with session changes")
+		}
+	}
+	session.mu.Unlock()
+
+	logger.WithFields(logrus.Fields{
+		"upstream_pubkey": upstreamPubkey,
+		"new_allotment":   newAllotment,
+		"current_usage":   currentUsage,
+		"total_spent":     session.TotalSpent,
+	}).Info("Session renewed successfully")
+
+	return nil
+}
+
+// GetActiveSessions returns all currently active sessions
+func (c *Chandler) GetActiveSessions() map[string]*ChandlerSession {
+	c.mu.RLock()
+	defer c.mu.RUnlock()
+
+	result := make(map[string]*ChandlerSession)
+	for k, v := range c.sessions {
+		if v.Status == SessionActive {
+			result[k] = v
+		}
+	}
+	return result
+}
+
+// GetSessionByPubkey returns a session by upstream pubkey
+func (c *Chandler) GetSessionByPubkey(pubkey string) (*ChandlerSession, error) {
+	c.mu.RLock()
+	defer c.mu.RUnlock()
+
+	session, exists := c.sessions[pubkey]
+	if !exists {
+		return nil, fmt.Errorf("session not found for pubkey: %s", pubkey)
+	}
+	return session, nil
+}
+
+// PauseSession pauses a session
+func (c *Chandler) PauseSession(pubkey string) error {
+	c.mu.RLock()
+	session, exists := c.sessions[pubkey]
+	c.mu.RUnlock()
+
+	if !exists {
+		return fmt.Errorf("session not found for pubkey: %s", pubkey)
+	}
+
+	session.mu.Lock()
+	defer session.mu.Unlock()
+
+	if session.UsageTracker != nil {
+		session.UsageTracker.Stop()
+	}
+	session.Status = SessionPaused
+
+	logger.WithField("upstream_pubkey", pubkey).Info("Session paused")
+	return nil
+}
+
+// ResumeSession resumes a paused session
+func (c *Chandler) ResumeSession(pubkey string) error {
+	c.mu.RLock()
+	session, exists := c.sessions[pubkey]
+	c.mu.RUnlock()
+
+	if !exists {
+		return fmt.Errorf("session not found for pubkey: %s", pubkey)
+	}
+
+	session.mu.Lock()
+	defer session.mu.Unlock()
+
+	err := c.createUsageTracker(session)
+	if err != nil {
+		return fmt.Errorf("failed to restart usage tracker: %w", err)
+	}
+
+	session.Status = SessionActive
+
+	logger.WithField("upstream_pubkey", pubkey).Info("Session resumed")
+	return nil
+}
+
+// TerminateSession terminates a session
+func (c *Chandler) TerminateSession(pubkey string) error {
+	c.mu.Lock()
+	defer c.mu.Unlock()
+
+	session, exists := c.sessions[pubkey]
+	if !exists {
+		return fmt.Errorf("session not found for pubkey: %s", pubkey)
+	}
+
+	if session.UsageTracker != nil {
+		session.UsageTracker.Stop()
+	}
+
+	delete(c.sessions, pubkey)
+
+	logger.WithField("upstream_pubkey", pubkey).Info("Session terminated")
+	return nil
+}
+
+// createAndSendPayment creates a payment event and sends it to the upstream TollGate
+func (c *Chandler) createAndSendPayment(session *ChandlerSession, proposal *PaymentProposal) (*nostr.Event, error) {
+	// Create payment token through merchant
+	paymentAmount := proposal.Steps * proposal.PricingOption.PricePerStep
+	paymentToken, err := c.merchant.CreatePaymentTokenWithOverpayment(proposal.PricingOption.MintURL, paymentAmount, 10000, 100)
+	if err != nil {
+		return nil, fmt.Errorf("failed to create payment token: %w", err)
+	}
+
+	// Get customer private key from session
+	customerPrivateKey := session.CustomerPrivateKey
+	customerPublicKey, _ := nostr.GetPublicKey(customerPrivateKey)
+
+	// Get MAC address from session's upstream tollgate object
+	macAddress := session.UpstreamTollgate.MacAddress
+
+	// Create payment event
+	paymentEvent := nostr.Event{
+		Kind:      21000,
+		PubKey:    customerPublicKey,
+		CreatedAt: nostr.Now(),
+		Tags: nostr.Tags{
+			{"p", proposal.UpstreamPubkey},
+			{"device-identifier", "mac", macAddress},
+			{"payment", paymentToken},
+		},
+		Content: "",
+	}
+
+	// Sign with customer identity
+	err = paymentEvent.Sign(customerPrivateKey)
+	if err != nil {
+		return nil, fmt.Errorf("failed to sign payment event: %w", err)
+	}
+
+	// Send payment to upstream TollGate
+	sessionEvent, err := c.sendPaymentToUpstream(&paymentEvent, session.UpstreamTollgate.GatewayIP)
+	if err != nil {
+		return nil, fmt.Errorf("failed to send payment to upstream: %w", err)
+	}
+
+	logger.WithFields(logrus.Fields{
+		"upstream_pubkey": proposal.UpstreamPubkey,
+		"amount":          paymentAmount,
+		"steps":           proposal.Steps,
+		"reason":          proposal.Reason,
+	}).Info("Payment sent successfully to upstream TollGate")
+
+	return sessionEvent, nil
+}
+
+// sendPaymentToUpstream sends a payment event to an upstream TollGate and returns the session event
+func (c *Chandler) sendPaymentToUpstream(paymentEvent *nostr.Event, gatewayIP string) (*nostr.Event, error) {
+	// Marshal payment event to JSON
+	paymentBytes, err := json.Marshal(paymentEvent)
+	if err != nil {
+		return nil, fmt.Errorf("failed to marshal payment event: %w", err)
+	}
+
+	// Send HTTP POST to upstream TollGate (TIP-03)
+	url := fmt.Sprintf("http://%s:2121/", gatewayIP)
+
+	// Create HTTP client with timeout
+	client := &http.Client{
+		Timeout: 30 * time.Second,
+	}
+
+	// Create request with proper headers
+	req, err := http.NewRequest("POST", url, bytes.NewBuffer(paymentBytes))
+	req.Close = true
+
+	if err != nil {
+		return nil, fmt.Errorf("failed to create HTTP request: %w", err)
+	}
+
+	req.Header.Set("Content-Type", "application/json")
+	req.Header.Set("User-Agent", "TollGate-Chandler/1.0")
+
+	logger.WithFields(logrus.Fields{
+		"url":          url,
+		"payload_size": len(paymentBytes),
+	}).Info("Sending payment to upstream TollGate")
+
+	resp, err := client.Do(req)
+	if err != nil {
+		return nil, fmt.Errorf("failed to send HTTP request: %w", err)
+	}
+	defer resp.Body.Close()
+
+	// Read response body for logging
+	responseBody, err := io.ReadAll(resp.Body)
+	if err != nil {
+		logger.WithFields(logrus.Fields{
+			"url":         url,
+			"status_code": resp.StatusCode,
+			"error":       err,
+		}).Error("Failed to read response body")
+		return nil, fmt.Errorf("failed to read response body: %w", err)
+	}
+
+	logger.WithFields(logrus.Fields{
+		"url":           url,
+		"status_code":   resp.StatusCode,
+		"response_size": len(responseBody),
+		"response_body": string(responseBody),
+	}).Info("Received response from upstream TollGate")
+
+	// Check response status
+	if resp.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf("upstream TollGate rejected payment with status: %d, body: %s", resp.StatusCode, string(responseBody))
+	}
+
+	// Parse session event from response
+	var sessionEvent nostr.Event
+	err = json.Unmarshal(responseBody, &sessionEvent)
+	if err != nil {
+		return nil, fmt.Errorf("failed to decode session event: %w", err)
+	}
+
+	// Validate session event
+	if sessionEvent.Kind != 1022 {
+		return nil, fmt.Errorf("invalid session event kind: %d", sessionEvent.Kind)
+	}
+
+	return &sessionEvent, nil
+}
+
+// createUsageTracker creates and starts the appropriate usage tracker for a session
+func (c *Chandler) createUsageTracker(session *ChandlerSession) error {
+	var tracker UsageTrackerInterface
+	var trackerType string
+
+	switch session.AdvertisementInfo.Metric {
+	case "milliseconds":
+		tracker = NewTimeUsageTracker()
+		trackerType = "time-based"
+	case "bytes":
+		tracker = NewDataUsageTracker(session.UpstreamTollgate.InterfaceName)
+		trackerType = "data-based"
+	default:
+		return fmt.Errorf("unsupported metric: %s", session.AdvertisementInfo.Metric)
+	}
+
+	logger.WithFields(logrus.Fields{
+		"upstream_pubkey":    session.UpstreamTollgate.Advertisement.PubKey,
+		"tracker_type":       trackerType,
+		"metric":             session.AdvertisementInfo.Metric,
+		"interface":          session.UpstreamTollgate.InterfaceName,
+		"total_allotment":    session.TotalAllotment,
+		"renewal_thresholds": session.RenewalThresholds,
+	}).Info("🔍 Creating usage tracker for session monitoring")
+
+	// Set renewal thresholds
+	err := tracker.SetRenewalThresholds(session.RenewalThresholds)
+	if err != nil {
+		logger.WithFields(logrus.Fields{
+			"upstream_pubkey": session.UpstreamTollgate.Advertisement.PubKey,
+			"error":           err,
+		}).Error("Failed to set renewal thresholds")
+		return fmt.Errorf("failed to set renewal thresholds: %w", err)
+	}
+
+	// Start tracking
+	logger.WithFields(logrus.Fields{
+		"upstream_pubkey": session.UpstreamTollgate.Advertisement.PubKey,
+		"tracker_type":    trackerType,
+	}).Info("▶️  Starting usage tracker monitoring")
+
+	err = tracker.Start(session, c)
+	if err != nil {
+		logger.WithFields(logrus.Fields{
+			"upstream_pubkey": session.UpstreamTollgate.Advertisement.PubKey,
+			"tracker_type":    trackerType,
+			"error":           err,
+		}).Error("Failed to start usage tracker")
+		return fmt.Errorf("failed to start usage tracker: %w", err)
+	}
+
+	session.UsageTracker = tracker
+
+	logger.WithFields(logrus.Fields{
+		"upstream_pubkey": session.UpstreamTollgate.Advertisement.PubKey,
+		"tracker_type":    trackerType,
+		"metric":          session.AdvertisementInfo.Metric,
+	}).Info("✅ Usage tracker successfully started and monitoring session")
+
+	return nil
+}
+
+// extractAllotment extracts the allotment value from a session event
+func (c *Chandler) extractAllotment(sessionEvent *nostr.Event) (uint64, error) {
+	for _, tag := range sessionEvent.Tags {
+		if len(tag) >= 2 && tag[0] == "allotment" {
+			allotment, err := strconv.ParseUint(tag[1], 10, 64)
+			if err != nil {
+				return 0, fmt.Errorf("failed to parse allotment: %w", err)
+			}
+			return allotment, nil
+		}
+	}
+	return 0, fmt.Errorf("no allotment tag found in session event")
+}
+
+// checkAdvertisementChanges compares the current advertisement with the latest from upstream
+func (c *Chandler) checkAdvertisementChanges(session *ChandlerSession) {
+	// TODO: Implement advertisement fetching and comparison
+	// For now, we'll just log that we should check for changes
+	logger.WithFields(logrus.Fields{
+		"upstream_pubkey": session.UpstreamTollgate.Advertisement.PubKey,
+	}).Debug("Should check for advertisement changes")
+}
+
+// selectCompatiblePricingOption finds the best pricing option that matches our available mints
+func (c *Chandler) selectCompatiblePricingOption(upstreamOptions []tollgate_protocol.PricingOption) (*tollgate_protocol.PricingOption, error) {
+	ourMints := c.merchant.GetAcceptedMints()
+
+	// Create a map of our mint URLs with their units for quick lookup
+	ourMintMap := make(map[string]string) // mint URL -> unit
+	for _, mint := range ourMints {
+		ourMintMap[mint.URL] = mint.PriceUnit
+	}
+
+	var compatibleOptions []tollgate_protocol.PricingOption
+
+	// Find all compatible options (same mint URL and unit)
+	for _, upstreamOption := range upstreamOptions {
+		if ourUnit, exists := ourMintMap[upstreamOption.MintURL]; exists {
+			if ourUnit == upstreamOption.PriceUnit {
+				compatibleOptions = append(compatibleOptions, upstreamOption)
+			}
+		}
+	}
+
+	if len(compatibleOptions) == 0 {
+		return nil, fmt.Errorf("no compatible mints found - upstream mints don't overlap with our accepted mints")
+	}
+
+	// Select the cheapest compatible option
+	best := &compatibleOptions[0]
+	for i := range compatibleOptions {
+		if compatibleOptions[i].PricePerStep < best.PricePerStep {
+			best = &compatibleOptions[i]
+		}
+	}
+
+	logger.WithFields(logrus.Fields{
+		"selected_mint":      best.MintURL,
+		"selected_unit":      best.PriceUnit,
+		"price_per_step":     best.PricePerStep,
+		"compatible_options": len(compatibleOptions),
+	}).Debug("Selected compatible pricing option")
+
+	return best, nil
+}
diff --git a/src/chandler/chandler_test.go b/src/chandler/chandler_test.go
new file mode 100644
index 0000000..f6335c5
--- /dev/null
+++ b/src/chandler/chandler_test.go
@@ -0,0 +1,122 @@
+package chandler
+
+import (
+	"testing"
+
+	"github.com/OpenTollGate/tollgate-module-basic-go/src/config_manager"
+	"github.com/OpenTollGate/tollgate-module-basic-go/src/tollgate_protocol"
+)
+
+// Mock implementations for testing
+
+type mockMerchant struct{}
+
+func (m *mockMerchant) CreatePaymentToken(mintURL string, amount uint64) (string, error) {
+	return "mock_payment_token", nil
+}
+
+func (m *mockMerchant) GetAcceptedMints() []config_manager.MintConfig {
+	return []config_manager.MintConfig{
+		{
+			URL:       "https://mock.mint.com",
+			PriceUnit: "sat",
+		},
+	}
+}
+
+func (m *mockMerchant) GetBalance() uint64 {
+	return 10000 // Mock balance
+}
+
+func (m *mockMerchant) GetBalanceByMint(mintURL string) uint64 {
+	return 10000 // Mock balance
+}
+
+func TestChandlerInterface(t *testing.T) {
+	// Basic test to ensure the interface methods are defined correctly
+	// This test verifies compilation of the interface methods
+
+	// Test that we can create interface methods without errors
+	var _ ChandlerInterface = (*Chandler)(nil)
+
+	t.Log("ChandlerInterface methods compiled successfully")
+}
+
+func TestMockMerchant(t *testing.T) {
+	merchant := &mockMerchant{}
+
+	// Test CreatePaymentToken
+	token, err := merchant.CreatePaymentToken("https://test.mint.com", 100)
+	if err != nil {
+		t.Errorf("CreatePaymentToken failed: %v", err)
+	}
+	if token != "mock_payment_token" {
+		t.Errorf("Expected 'mock_payment_token', got '%s'", token)
+	}
+
+	// Test GetAcceptedMints
+	mints := merchant.GetAcceptedMints()
+	if len(mints) != 1 {
+		t.Errorf("Expected 1 mint, got %d", len(mints))
+	}
+
+	// Test GetBalance
+	balance := merchant.GetBalance()
+	if balance != 10000 {
+		t.Errorf("Expected balance 10000, got %d", balance)
+	}
+
+	// Test GetBalanceByMint
+	balanceByMint := merchant.GetBalanceByMint("https://test.mint.com")
+	if balanceByMint != 10000 {
+		t.Errorf("Expected balance by mint 10000, got %d", balanceByMint)
+	}
+}
+
+func TestUsageTrackerInterface(t *testing.T) {
+	// Test that usage tracker interfaces are properly defined
+	var _ UsageTrackerInterface = (*TimeUsageTracker)(nil)
+	var _ UsageTrackerInterface = (*DataUsageTracker)(nil)
+
+	t.Log("UsageTrackerInterface methods compiled successfully")
+}
+
+func TestPricingOptions(t *testing.T) {
+	// Test ValidateBudgetConstraints function exists and works with valid inputs
+	proposal := &PaymentProposal{
+		UpstreamPubkey: "test-pubkey",
+		Steps:          10,
+		PricingOption: &tollgate_protocol.PricingOption{
+			AssetType:    "cashu",
+			PricePerStep: 1,
+			PriceUnit:    "sat",
+			MintURL:      "https://test.mint.com",
+			MinSteps:     1,
+		},
+		Reason:             "test",
+		EstimatedAllotment: 600000, // 10 minutes in milliseconds
+	}
+
+	err := ValidateBudgetConstraints(proposal, 0.01, 0.001, "milliseconds", 60000) // 60000 ms per step
+	if err != nil {
+		t.Errorf("ValidateBudgetConstraints failed with valid inputs: %v", err)
+	}
+}
+
+func TestTrustPolicy(t *testing.T) {
+	// Test ValidateTrustPolicy function
+	err := ValidateTrustPolicy("test-pubkey", []string{}, []string{}, "trust_all")
+	if err != nil {
+		t.Errorf("ValidateTrustPolicy failed with trust_all policy: %v", err)
+	}
+
+	err = ValidateTrustPolicy("test-pubkey", []string{}, []string{}, "trust_none")
+	if err == nil {
+		t.Error("Expected ValidateTrustPolicy to fail with trust_none policy")
+	}
+
+	err = ValidateTrustPolicy("blocked-pubkey", []string{}, []string{"blocked-pubkey"}, "trust_all")
+	if err == nil {
+		t.Error("Expected ValidateTrustPolicy to fail with blocked pubkey")
+	}
+}
diff --git a/src/chandler/data_usage_tracker.go b/src/chandler/data_usage_tracker.go
new file mode 100644
index 0000000..ade50bc
--- /dev/null
+++ b/src/chandler/data_usage_tracker.go
@@ -0,0 +1,287 @@
+package chandler
+
+import (
+	"bufio"
+	"fmt"
+	"os"
+	"strconv"
+	"strings"
+	"time"
+
+	"github.com/sirupsen/logrus"
+)
+
+// NewDataUsageTracker creates a new data-based usage tracker
+func NewDataUsageTracker(interfaceName string) *DataUsageTracker {
+	return &DataUsageTracker{
+		interfaceName: interfaceName,
+		done:          make(chan bool),
+	}
+}
+
+// Start begins monitoring data usage for the session
+func (d *DataUsageTracker) Start(session *ChandlerSession, chandler ChandlerInterface) error {
+	d.mu.Lock()
+	defer d.mu.Unlock()
+
+	d.upstreamPubkey = session.UpstreamTollgate.Advertisement.PubKey
+	d.chandler = chandler
+
+	// Get initial byte count for the interface
+	initialBytes, err := d.getInterfaceBytes()
+	if err != nil {
+		return err
+	}
+
+	d.startBytes = initialBytes
+	d.currentBytes = initialBytes
+	d.totalAllotment = session.TotalAllotment
+	d.currentIncrement = session.TotalAllotment
+	d.triggered = make(map[float64]bool) // Initialize triggered map
+
+	// Start monitoring with 5-second precision for data usage
+	// Data usage needs polling since we can't predict when network traffic occurs
+	d.ticker = time.NewTicker(500 * time.Millisecond)
+
+	go d.monitor()
+
+	logrus.WithFields(logrus.Fields{
+		"upstream_pubkey": d.upstreamPubkey,
+		"interface":       d.interfaceName,
+		"start_bytes":     d.startBytes,
+		"total_allotment": d.totalAllotment,
+		"thresholds":      d.thresholds,
+	}).Info("Data usage tracker started")
+
+	return nil
+}
+
+// Stop stops the data usage tracker
+func (d *DataUsageTracker) Stop() error {
+	d.mu.Lock()
+	defer d.mu.Unlock()
+
+	if d.ticker != nil {
+		d.ticker.Stop()
+	}
+
+	select {
+	case d.done <- true:
+	default:
+	}
+
+	logrus.WithFields(logrus.Fields{
+		"upstream_pubkey": d.upstreamPubkey,
+		"total_usage":     d.GetCurrentUsage(),
+	}).Info("Data usage tracker stopped")
+
+	return nil
+}
+
+// GetCurrentUsage returns current data usage in bytes
+func (d *DataUsageTracker) GetCurrentUsage() uint64 {
+	d.mu.RLock()
+	defer d.mu.RUnlock()
+
+	if d.currentBytes < d.startBytes {
+		return 0 // Interface was reset
+	}
+
+	return d.currentBytes - d.startBytes
+}
+
+// UpdateUsage manually updates the current byte count
+func (d *DataUsageTracker) UpdateUsage(amount uint64) error {
+	d.mu.Lock()
+	defer d.mu.Unlock()
+
+	d.currentBytes = amount
+	return nil
+}
+
+// SetRenewalThresholds sets the thresholds for renewal callbacks
+func (d *DataUsageTracker) SetRenewalThresholds(thresholds []float64) error {
+	d.mu.Lock()
+	defer d.mu.Unlock()
+
+	d.thresholds = make([]float64, len(thresholds))
+	copy(d.thresholds, thresholds)
+
+	return nil
+}
+
+// SessionChanged is called when the session is updated
+func (d *DataUsageTracker) SessionChanged(session *ChandlerSession) error {
+	d.mu.Lock()
+	defer d.mu.Unlock()
+
+	// Calculate the increment from the previous total allotment to the new total allotment
+	previousTotalAllotment := d.totalAllotment
+	d.totalAllotment = session.TotalAllotment
+	d.currentIncrement = d.totalAllotment - previousTotalAllotment
+
+	// Reset triggered thresholds for the new increment
+	d.triggered = make(map[float64]bool)
+
+	logrus.WithFields(logrus.Fields{
+		"upstream_pubkey":          d.upstreamPubkey,
+		"previous_total_allotment": previousTotalAllotment,
+		"new_total_allotment":      d.totalAllotment,
+		"current_increment":        d.currentIncrement,
+	}).Info("Session changed, updating data usage tracker")
+
+	return nil
+}
+
+// monitor runs the monitoring loop for data usage
+func (d *DataUsageTracker) monitor() {
+	for {
+		select {
+		case <-d.done:
+			return
+		case <-d.ticker.C:
+			d.updateCurrentBytes()
+			d.checkThresholds(d.triggered)
+		}
+	}
+}
+
+// updateCurrentBytes updates the current byte count from the interface
+func (d *DataUsageTracker) updateCurrentBytes() {
+	bytes, err := d.getInterfaceBytes()
+	if err != nil {
+		logrus.WithFields(logrus.Fields{
+			"interface": d.interfaceName,
+			"error":     err,
+		}).Warn("Failed to get interface bytes")
+		return
+	}
+
+	d.mu.Lock()
+	d.currentBytes = bytes
+	d.mu.Unlock()
+}
+
+// checkThresholds checks if any renewal thresholds have been reached
+func (d *DataUsageTracker) checkThresholds(triggered map[float64]bool) {
+	d.mu.RLock()
+	currentUsage := d.GetCurrentUsage()
+	totalAllotment := d.totalAllotment
+	upstreamPubkey := d.upstreamPubkey
+	thresholds := d.thresholds
+	d.mu.RUnlock()
+
+	if d.currentIncrement == 0 {
+		return
+	}
+
+	usageInCurrentIncrement := currentUsage - (totalAllotment - d.currentIncrement)
+	if usageInCurrentIncrement < 0 {
+		usageInCurrentIncrement = 0
+	}
+
+	usagePercent := float64(usageInCurrentIncrement) / float64(d.currentIncrement)
+
+	for _, threshold := range thresholds {
+		if usagePercent >= threshold && !d.triggered[threshold] {
+			d.triggered[threshold] = true
+
+			logrus.WithFields(logrus.Fields{
+				"upstream_pubkey": upstreamPubkey,
+				"threshold":       threshold,
+				"usage_percent":   usagePercent * 100,
+				"current_usage":   currentUsage,
+				"total_allotment": totalAllotment,
+			}).Info("Data usage threshold reached, triggering renewal")
+
+			// Call the chandler's renewal handler
+			go func(pubkey string, usage uint64) {
+				err := d.chandler.HandleUpcomingRenewal(pubkey, usage)
+				if err != nil {
+					logrus.WithFields(logrus.Fields{
+						"upstream_pubkey": pubkey,
+						"error":           err,
+					}).Error("Failed to handle upcoming renewal")
+				}
+			}(upstreamPubkey, currentUsage)
+		}
+	}
+}
+
+// getInterfaceBytes reads the current byte count for the interface from /proc/net/dev
+// This function is designed to work on both 32-bit and 64-bit systems
+func (d *DataUsageTracker) getInterfaceBytes() (uint64, error) {
+	file, err := os.Open("/proc/net/dev")
+	if err != nil {
+		return 0, fmt.Errorf("failed to open /proc/net/dev: %w", err)
+	}
+	defer file.Close()
+
+	scanner := bufio.NewScanner(file)
+
+	// Skip header lines
+	if !scanner.Scan() || !scanner.Scan() {
+		return 0, fmt.Errorf("failed to read /proc/net/dev header")
+	}
+
+	// Look for our interface
+	for scanner.Scan() {
+		line := scanner.Text()
+
+		// Parse interface line: "  eth0: bytes packets errs drop..."
+		colonIndex := strings.Index(line, ":")
+		if colonIndex == -1 {
+			continue
+		}
+
+		interfaceName := strings.TrimSpace(line[:colonIndex])
+		if interfaceName != d.interfaceName {
+			continue
+		}
+
+		// Parse the statistics after the colon
+		stats := strings.Fields(line[colonIndex+1:])
+		if len(stats) < 16 {
+			return 0, fmt.Errorf("insufficient statistics for interface %s", d.interfaceName)
+		}
+
+		// /proc/net/dev format:
+		// RX: bytes packets errs drop fifo frame compressed multicast
+		// TX: bytes packets errs drop fifo colls carrier compressed
+
+		// Get RX bytes (index 0) and TX bytes (index 8)
+		rxBytes, err := parseUint64Safe(stats[0])
+		if err != nil {
+			return 0, fmt.Errorf("failed to parse RX bytes for %s: %w", d.interfaceName, err)
+		}
+
+		txBytes, err := parseUint64Safe(stats[8])
+		if err != nil {
+			return 0, fmt.Errorf("failed to parse TX bytes for %s: %w", d.interfaceName, err)
+		}
+
+		// Return total bytes (RX + TX)
+		totalBytes := rxBytes + txBytes
+
+		logrus.WithFields(logrus.Fields{
+			"interface":   d.interfaceName,
+			"rx_bytes":    rxBytes,
+			"tx_bytes":    txBytes,
+			"total_bytes": totalBytes,
+		}).Debug("Updated interface byte counts")
+
+		return totalBytes, nil
+	}
+
+	if err := scanner.Err(); err != nil {
+		return 0, fmt.Errorf("error reading /proc/net/dev: %w", err)
+	}
+
+	return 0, fmt.Errorf("interface %s not found in /proc/net/dev", d.interfaceName)
+}
+
+// parseUint64Safe safely parses a uint64 from string, handling 32-bit system limitations
+func parseUint64Safe(s string) (uint64, error) {
+	// strconv.ParseUint handles both 32-bit and 64-bit systems correctly
+	return strconv.ParseUint(strings.TrimSpace(s), 10, 64)
+}
diff --git a/src/chandler/go.mod b/src/chandler/go.mod
new file mode 100644
index 0000000..1197695
--- /dev/null
+++ b/src/chandler/go.mod
@@ -0,0 +1,46 @@
+module github.com/OpenTollGate/tollgate-module-basic-go/src/chandler
+
+go 1.24.2
+
+toolchain go1.24.5
+
+require (
+	github.com/OpenTollGate/tollgate-module-basic-go/src/config_manager v0.0.0
+	github.com/OpenTollGate/tollgate-module-basic-go/src/merchant v0.0.0
+	github.com/OpenTollGate/tollgate-module-basic-go/src/tollgate_protocol v0.0.0
+	github.com/nbd-wtf/go-nostr v0.51.10
+	github.com/sirupsen/logrus v1.9.3
+)
+
+replace github.com/OpenTollGate/tollgate-module-basic-go/src/tollgate_protocol => ../tollgate_protocol
+
+replace github.com/OpenTollGate/tollgate-module-basic-go/src/config_manager => ../config_manager
+
+replace github.com/OpenTollGate/tollgate-module-basic-go/src/merchant => ../merchant
+
+require (
+	github.com/ImVexed/fasturl v0.0.0-20230304231329-4e41488060f3 // indirect
+	github.com/btcsuite/btcd/btcec/v2 v2.3.4 // indirect
+	github.com/btcsuite/btcd/chaincfg/chainhash v1.1.0 // indirect
+	github.com/bytedance/sonic v1.13.2 // indirect
+	github.com/bytedance/sonic/loader v0.2.4 // indirect
+	github.com/cloudwego/base64x v0.1.5 // indirect
+	github.com/coder/websocket v1.8.13 // indirect
+	github.com/decred/dcrd/crypto/blake256 v1.1.0 // indirect
+	github.com/decred/dcrd/dcrec/secp256k1/v4 v4.4.0 // indirect
+	github.com/hashicorp/go-version v1.7.0 // indirect
+	github.com/josharian/intern v1.0.0 // indirect
+	github.com/json-iterator/go v1.1.12 // indirect
+	github.com/klauspost/cpuid/v2 v2.2.10 // indirect
+	github.com/mailru/easyjson v0.9.0 // indirect
+	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
+	github.com/modern-go/reflect2 v1.0.2 // indirect
+	github.com/puzpuzpuz/xsync/v3 v3.5.1 // indirect
+	github.com/tidwall/gjson v1.18.0 // indirect
+	github.com/tidwall/match v1.1.1 // indirect
+	github.com/tidwall/pretty v1.2.1 // indirect
+	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
+	golang.org/x/arch v0.17.0 // indirect
+	golang.org/x/exp v0.0.0-20250506013437-ce4c2cf36ca6 // indirect
+	golang.org/x/sys v0.33.0 // indirect
+)
diff --git a/src/chandler/go.sum b/src/chandler/go.sum
new file mode 100644
index 0000000..8eb43ee
--- /dev/null
+++ b/src/chandler/go.sum
@@ -0,0 +1,84 @@
+github.com/ImVexed/fasturl v0.0.0-20230304231329-4e41488060f3 h1:ClzzXMDDuUbWfNNZqGeYq4PnYOlwlOVIvSyNaIy0ykg=
+github.com/ImVexed/fasturl v0.0.0-20230304231329-4e41488060f3/go.mod h1:we0YA5CsBbH5+/NUzC/AlMmxaDtWlXeNsqrwXjTzmzA=
+github.com/btcsuite/btcd/btcec/v2 v2.3.4 h1:3EJjcN70HCu/mwqlUsGK8GcNVyLVxFDlWurTXGPFfiQ=
+github.com/btcsuite/btcd/btcec/v2 v2.3.4/go.mod h1:zYzJ8etWJQIv1Ogk7OzpWjowwOdXY1W/17j2MW85J04=
+github.com/btcsuite/btcd/chaincfg/chainhash v1.1.0 h1:59Kx4K6lzOW5w6nFlA0v5+lk/6sjybR934QNHSJZPTQ=
+github.com/btcsuite/btcd/chaincfg/chainhash v1.1.0/go.mod h1:7SFka0XMvUgj3hfZtydOrQY2mwhPclbT2snogU7SQQc=
+github.com/bytedance/sonic v1.13.2 h1:8/H1FempDZqC4VqjptGo14QQlJx8VdZJegxs6wwfqpQ=
+github.com/bytedance/sonic v1.13.2/go.mod h1:o68xyaF9u2gvVBuGHPlUVCy+ZfmNNO5ETf1+KgkJhz4=
+github.com/bytedance/sonic/loader v0.1.1/go.mod h1:ncP89zfokxS5LZrJxl5z0UJcsk4M4yY2JpfqGeCtNLU=
+github.com/bytedance/sonic/loader v0.2.4 h1:ZWCw4stuXUsn1/+zQDqeE7JKP+QO47tz7QCNan80NzY=
+github.com/bytedance/sonic/loader v0.2.4/go.mod h1:N8A3vUdtUebEY2/VQC0MyhYeKUFosQU6FxH2JmUe6VI=
+github.com/cloudwego/base64x v0.1.5 h1:XPciSp1xaq2VCSt6lF0phncD4koWyULpl5bUxbfCyP4=
+github.com/cloudwego/base64x v0.1.5/go.mod h1:0zlkT4Wn5C6NdauXdJRhSKRlJvmclQ1hhJgA0rcu/8w=
+github.com/cloudwego/iasm v0.2.0/go.mod h1:8rXZaNYT2n95jn+zTI1sDr+IgcD2GVs0nlbbQPiEFhY=
+github.com/coder/websocket v1.8.13 h1:f3QZdXy7uGVz+4uCJy2nTZyM0yTBj8yANEHhqlXZ9FE=
+github.com/coder/websocket v1.8.13/go.mod h1:LNVeNrXQZfe5qhS9ALED3uA+l5pPqvwXg3CKoDBB2gs=
+github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
+github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
+github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
+github.com/decred/dcrd/crypto/blake256 v1.1.0 h1:zPMNGQCm0g4QTY27fOCorQW7EryeQ/U0x++OzVrdms8=
+github.com/decred/dcrd/crypto/blake256 v1.1.0/go.mod h1:2OfgNZ5wDpcsFmHmCK5gZTPcCXqlm2ArzUIkw9czNJo=
+github.com/decred/dcrd/dcrec/secp256k1/v4 v4.4.0 h1:NMZiJj8QnKe1LgsbDayM4UoHwbvwDRwnI3hwNaAHRnc=
+github.com/decred/dcrd/dcrec/secp256k1/v4 v4.4.0/go.mod h1:ZXNYxsqcloTdSy/rNShjYzMhyjf0LaoftYK0p+A3h40=
+github.com/dvyukov/go-fuzz v0.0.0-20200318091601-be3528f3a813/go.mod h1:11Gm+ccJnvAhCNLlf5+cS9KjtbaD5I5zaZpFMsTHWTw=
+github.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=
+github.com/hashicorp/go-version v1.7.0 h1:5tqGy27NaOTB8yJKUZELlFAS/LTKJkrmONwQKeRZfjY=
+github.com/hashicorp/go-version v1.7.0/go.mod h1:fltr4n8CU8Ke44wwGCBoEymUuxUHl09ZGVZPK5anwXA=
+github.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=
+github.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=
+github.com/json-iterator/go v1.1.12 h1:PV8peI4a0ysnczrg+LtxykD8LfKY9ML6u2jnxaEnrnM=
+github.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=
+github.com/klauspost/cpuid/v2 v2.0.9/go.mod h1:FInQzS24/EEf25PyTYn52gqo7WaD8xa0213Md/qVLRg=
+github.com/klauspost/cpuid/v2 v2.2.10 h1:tBs3QSyvjDyFTq3uoc/9xFpCuOsJQFNPiAhYdw2skhE=
+github.com/klauspost/cpuid/v2 v2.2.10/go.mod h1:hqwkgyIinND0mEev00jJYCxPNVRVXFQeu1XKlok6oO0=
+github.com/knz/go-libedit v1.10.1/go.mod h1:MZTVkCWyz0oBc7JOWP3wNAzd002ZbM/5hgShxwh4x8M=
+github.com/mailru/easyjson v0.9.0 h1:PrnmzHw7262yW8sTBwxi1PdJA3Iw/EKBa8psRf7d9a4=
+github.com/mailru/easyjson v0.9.0/go.mod h1:1+xMtQp2MRNVL/V1bOzuP3aP8VNwRW55fQUto+XFtTU=
+github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
+github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=
+github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
+github.com/modern-go/reflect2 v1.0.2 h1:xBagoLtFs94CBntxluKeaWgTMpvLxC4ur3nMaC9Gz0M=
+github.com/modern-go/reflect2 v1.0.2/go.mod h1:yWuevngMOJpCy52FWWMvUC8ws7m/LJsjYzDa0/r8luk=
+github.com/nbd-wtf/go-nostr v0.51.10 h1:MxyN/bRNqdeLbiN9lODbXduLRkYwy7SDTm73uGrsdU4=
+github.com/nbd-wtf/go-nostr v0.51.10/go.mod h1:IF30/Cm4AS90wd1GjsFJbBqq7oD1txo+2YUFYXqK3Nc=
+github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
+github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
+github.com/puzpuzpuz/xsync/v3 v3.5.1 h1:GJYJZwO6IdxN/IKbneznS6yPkVC+c3zyY/j19c++5Fg=
+github.com/puzpuzpuz/xsync/v3 v3.5.1/go.mod h1:VjzYrABPabuM4KyBh1Ftq6u8nhwY5tBPKP9jpmh0nnA=
+github.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=
+github.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=
+github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
+github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
+github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
+github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
+github.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
+github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
+github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
+github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
+github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
+github.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=
+github.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
+github.com/tidwall/gjson v1.18.0 h1:FIDeeyB800efLX89e5a8Y0BNH+LOngJyGrIWxG2FKQY=
+github.com/tidwall/gjson v1.18.0/go.mod h1:/wbyibRr2FHMks5tjHJ5F8dMZh3AcwJEMf5vlfC0lxk=
+github.com/tidwall/match v1.1.1 h1:+Ho715JplO36QYgwN9PGYNhgZvoUSc9X2c80KVTi+GA=
+github.com/tidwall/match v1.1.1/go.mod h1:eRSPERbgtNPcGhD8UCthc6PmLEQXEWd3PRB5JTxsfmM=
+github.com/tidwall/pretty v1.2.0/go.mod h1:ITEVvHYasfjBbM0u2Pg8T2nJnzm8xPwvNhhsoaGGjNU=
+github.com/tidwall/pretty v1.2.1 h1:qjsOFOWWQl+N3RsoF5/ssm1pHmJJwhjlSbZ51I6wMl4=
+github.com/tidwall/pretty v1.2.1/go.mod h1:ITEVvHYasfjBbM0u2Pg8T2nJnzm8xPwvNhhsoaGGjNU=
+github.com/twitchyliquid64/golang-asm v0.15.1 h1:SU5vSMR7hnwNxj24w34ZyCi/FmDZTkS4MhqMhdFk5YI=
+github.com/twitchyliquid64/golang-asm v0.15.1/go.mod h1:a1lVb/DtPvCB8fslRZhAngC2+aY1QWCk3Cedj/Gdt08=
+golang.org/x/arch v0.17.0 h1:4O3dfLzd+lQewptAHqjewQZQDyEdejz3VwgeYwkZneU=
+golang.org/x/arch v0.17.0/go.mod h1:bdwinDaKcfZUGpH09BB7ZmOfhalA8lQdzl62l8gGWsk=
+golang.org/x/exp v0.0.0-20250506013437-ce4c2cf36ca6 h1:y5zboxd6LQAqYIhHnB48p0ByQ/GnQx2BE33L8BOHQkI=
+golang.org/x/exp v0.0.0-20250506013437-ce4c2cf36ca6/go.mod h1:U6Lno4MTRCDY+Ba7aCcauB9T60gsv5s4ralQzP72ZoQ=
+golang.org/x/net v0.37.0 h1:1zLorHbz+LYj7MQlSf1+2tPIIgibq2eL5xkrGk6f+2c=
+golang.org/x/net v0.37.0/go.mod h1:ivrbrMbzFq5J41QOQh0siUuly180yBYtLp+CKbEaFx8=
+golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+golang.org/x/sys v0.33.0 h1:q3i8TbbEz+JRD9ywIRlyRAQbM0qF7hu24q3teo2hbuw=
+golang.org/x/sys v0.33.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
+gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
+gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
+gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
+gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
+nullprogram.com/x/optparse v1.0.0/go.mod h1:KdyPE+Igbe0jQUrVfMqDMeJQIJZEuyV7pjYmp6pbG50=
diff --git a/src/chandler/pricing.go b/src/chandler/pricing.go
new file mode 100644
index 0000000..d231d1c
--- /dev/null
+++ b/src/chandler/pricing.go
@@ -0,0 +1,159 @@
+package chandler
+
+import (
+	"fmt"
+
+	"github.com/OpenTollGate/tollgate-module-basic-go/src/tollgate_protocol"
+)
+
+// SelectBestPricingOption selects the best pricing option based on criteria
+// For now, it just returns the option with the lowest price per step
+func SelectBestPricingOption(options []tollgate_protocol.PricingOption, preferredUnit string) *tollgate_protocol.PricingOption {
+	if len(options) == 0 {
+		return nil
+	}
+
+	var best *tollgate_protocol.PricingOption
+
+	// First, try to find options with preferred unit
+	if preferredUnit != "" {
+		for i := range options {
+			if options[i].PriceUnit == preferredUnit {
+				if best == nil || options[i].PricePerStep < best.PricePerStep {
+					best = &options[i]
+				}
+			}
+		}
+	}
+
+	// If no preferred unit option found, select cheapest overall
+	if best == nil {
+		best = &options[0]
+		for i := range options {
+			if options[i].PricePerStep < best.PricePerStep {
+				best = &options[i]
+			}
+		}
+	}
+
+	return best
+}
+
+// ValidateBudgetConstraints checks if a payment proposal is within budget
+func ValidateBudgetConstraints(proposal *PaymentProposal, maxPricePerMs, maxPricePerByte float64, metric string, stepSize uint64) error {
+	if proposal == nil || proposal.PricingOption == nil {
+		return &ChandlerError{
+			Type:    ErrorTypeBudget,
+			Code:    "invalid-proposal",
+			Message: "proposal or pricing option is nil",
+		}
+	}
+
+	pricePerStep := float64(proposal.PricingOption.PricePerStep)
+
+	// Calculate price per unit of metric (millisecond or byte)
+	pricePerUnit := pricePerStep / float64(stepSize)
+	var maxPrice float64
+	var unitName string
+
+	switch metric {
+	case "milliseconds":
+		maxPrice = maxPricePerMs
+		unitName = "millisecond"
+	case "bytes":
+		maxPrice = maxPricePerByte
+		unitName = "byte"
+	default:
+		return &ChandlerError{
+			Type:    ErrorTypeBudget,
+			Code:    "unsupported-metric",
+			Message: "unsupported metric: " + metric,
+		}
+	}
+
+	if pricePerUnit > maxPrice {
+		return &ChandlerError{
+			Type:    ErrorTypeBudget,
+			Code:    "price-too-high",
+			Message: fmt.Sprintf("price per %s %.6f exceeds maximum %.6f (price per step: %.6f, step size: %d)", unitName, pricePerUnit, maxPrice, pricePerStep, stepSize),
+			Context: map[string]interface{}{
+				"price_per_step": pricePerStep,
+				"price_per_unit": pricePerUnit,
+				"max_price":      maxPrice,
+				"metric":         metric,
+				"step_size":      stepSize,
+			},
+		}
+	}
+
+	return nil
+}
+
+// CalculateAllotment calculates the allotment from steps and step size
+func CalculateAllotment(steps uint64, stepSize uint64) uint64 {
+	return steps * stepSize
+}
+
+// CalculateStepsFromBudget calculates how many steps can be purchased with given budget
+func CalculateStepsFromBudget(budget uint64, pricePerStep uint64, minSteps uint64) uint64 {
+	if pricePerStep == 0 {
+		return 0
+	}
+
+	steps := budget / pricePerStep
+	if steps < minSteps {
+		return 0 // Cannot afford minimum purchase
+	}
+
+	return steps
+}
+
+// ValidateTrustPolicy checks if an upstream pubkey is trusted
+func ValidateTrustPolicy(pubkey string, allowlist, blocklist []string, defaultPolicy string) error {
+	// Check blocklist first
+	for _, blocked := range blocklist {
+		if pubkey == blocked {
+			return &ChandlerError{
+				Type:           ErrorTypeTrust,
+				Code:           "pubkey-blocked",
+				Message:        "pubkey is in blocklist",
+				UpstreamPubkey: pubkey,
+			}
+		}
+	}
+
+	// If allowlist is specified, pubkey must be in it
+	if len(allowlist) > 0 {
+		for _, allowed := range allowlist {
+			if pubkey == allowed {
+				return nil // Found in allowlist
+			}
+		}
+		return &ChandlerError{
+			Type:           ErrorTypeTrust,
+			Code:           "pubkey-not-allowed",
+			Message:        "pubkey not in allowlist",
+			UpstreamPubkey: pubkey,
+		}
+	}
+
+	// Apply default policy
+	switch defaultPolicy {
+	case "trust_all":
+		return nil
+	case "trust_none":
+		return &ChandlerError{
+			Type:           ErrorTypeTrust,
+			Code:           "default-policy-deny",
+			Message:        "default policy is trust_none",
+			UpstreamPubkey: pubkey,
+		}
+	default:
+		return &ChandlerError{
+			Type:           ErrorTypeTrust,
+			Code:           "invalid-default-policy",
+			Message:        "unknown default policy: " + defaultPolicy,
+			UpstreamPubkey: pubkey,
+		}
+	}
+}
diff --git a/src/chandler/time_usage_tracker.go b/src/chandler/time_usage_tracker.go
new file mode 100644
index 0000000..6df3fdc
--- /dev/null
+++ b/src/chandler/time_usage_tracker.go
@@ -0,0 +1,241 @@
+package chandler
+
+import (
+	"sort"
+	"time"
+
+	"github.com/sirupsen/logrus"
+)
+
+// NewTimeUsageTracker creates a new time-based usage tracker
+func NewTimeUsageTracker() *TimeUsageTracker {
+	return &TimeUsageTracker{
+		done:   make(chan bool),
+		timers: make([]*time.Timer, 0),
+	}
+}
+
+// Start begins monitoring time usage for the session
+func (t *TimeUsageTracker) Start(session *ChandlerSession, chandler ChandlerInterface) error {
+	t.mu.Lock()
+	defer t.mu.Unlock()
+
+	t.upstreamPubkey = session.UpstreamTollgate.Advertisement.PubKey
+	t.chandler = chandler
+	t.startTime = time.Now()
+	t.pausedTime = 0
+	t.totalAllotment = session.TotalAllotment
+	t.currentIncrement = session.TotalAllotment
+
+	// Set up timers for each threshold
+	t.setupThresholdTimers(0) // Start with 0 usage at initialization
+
+	logrus.WithFields(logrus.Fields{
+		"upstream_pubkey": t.upstreamPubkey,
+		"total_allotment": t.totalAllotment,
+		"thresholds":      t.thresholds,
+	}).Info("Time usage tracker started with threshold timers")
+
+	return nil
+}
+
+// Stop stops the usage tracker
+func (t *TimeUsageTracker) Stop() error {
+	t.mu.Lock()
+	defer t.mu.Unlock()
+
+	// Stop all active timers
+	for _, timer := range t.timers {
+		timer.Stop()
+	}
+	t.timers = nil
+
+	select {
+	case t.done <- true:
+	default:
+	}
+
+	logrus.WithFields(logrus.Fields{
+		"upstream_pubkey": t.upstreamPubkey,
+		"total_usage":     t.GetCurrentUsage(),
+	}).Info("Time usage tracker stopped")
+
+	return nil
+}
+
+// GetCurrentUsage returns current usage in milliseconds
+func (t *TimeUsageTracker) GetCurrentUsage() uint64 {
+	t.mu.RLock()
+	defer t.mu.RUnlock()
+
+	if t.startTime.IsZero() {
+		return 0
+	}
+
+	elapsed := time.Since(t.startTime) - t.pausedTime
+	return uint64(elapsed.Milliseconds())
+}
+
+// UpdateUsage manually updates usage (not applicable for time tracking)
+func (t *TimeUsageTracker) UpdateUsage(amount uint64) error {
+	// Time tracking is automatic, manual updates don't apply
+	return nil
+}
+
+// SetRenewalThresholds sets the thresholds for renewal callbacks
+func (t *TimeUsageTracker) SetRenewalThresholds(thresholds []float64) error {
+	t.mu.Lock()
+	defer t.mu.Unlock()
+
+	t.thresholds = make([]float64, len(thresholds))
+	copy(t.thresholds, thresholds)
+
+	// If we're already started, reset timers
+	if t.upstreamPubkey != "" {
+		currentUsage := t.GetCurrentUsage()
+		t.setupThresholdTimers(currentUsage)
+	}
+
+	return nil
+}
+
+// SessionChanged is called when the session is updated
+func (t *TimeUsageTracker) SessionChanged(session *ChandlerSession) error {
+	// Get current usage before calling continuing to avoid deadlock
+	currentUsage := t.GetCurrentUsage()
+	t.mu.Lock()
+	defer t.mu.Unlock()
+
+	// Calculate the increment from the previous total allotment to the new total allotment
+	previousTotalAllotment := t.totalAllotment
+	t.totalAllotment = session.TotalAllotment
+	t.currentIncrement = t.totalAllotment - previousTotalAllotment
+
+	logrus.WithFields(logrus.Fields{
+		"upstream_pubkey":          t.upstreamPubkey,
+		"previous_total_allotment": previousTotalAllotment,
+		"new_total_allotment":      t.totalAllotment,
+		"current_increment":        t.currentIncrement,
+	}).Info("Session changed, updating usage tracker")
+
+	t.setupThresholdTimers(currentUsage)
+	return nil
+}
+
+// setupThresholdTimers creates timers for each threshold
+func (t *TimeUsageTracker) setupThresholdTimers(currentUsage uint64) {
+	logrus.WithFields(logrus.Fields{
+		"upstream_pubkey":   t.upstreamPubkey,
+		"total_allotment":   t.totalAllotment,
+		"current_increment": t.currentIncrement,
+		"thresholds":        t.thresholds,
+		"existing_timers":   len(t.timers),
+	}).Info("Setting up threshold timers")
+
+	// Stop existing timers
+	for _, timer := range t.timers {
+		timer.Stop()
+	}
+	t.timers = nil
+
+	if t.upstreamPubkey == "" || t.totalAllotment == 0 {
+		logrus.WithFields(logrus.Fields{
+			"upstream_pubkey": t.upstreamPubkey,
+			"total_allotment": t.totalAllotment,
+		}).Warn("Cannot setup threshold timers: upstreamPubkey is empty or total allotment is 0")
+		return
+	}
+
+	// Sort thresholds to ensure we process them in order
+	sortedThresholds := make([]float64, len(t.thresholds))
+	copy(sortedThresholds, t.thresholds)
+	sort.Float64s(sortedThresholds)
+
+	for _, threshold := range sortedThresholds {
+		var thresholdPoint uint64
+
+		// Calculate the threshold point based on the current increment
+		if t.currentIncrement == t.totalAllotment {
+			// First purchase: threshold is based on total allotment
+			thresholdPoint = uint64(float64(t.totalAllotment) * threshold)
+		} else {
+			// Renewal: threshold is at the end of previous allotment + 80% of current increment
+			previousAllotment := t.totalAllotment - t.currentIncrement
+			thresholdPoint = previousAllotment + uint64(float64(t.currentIncrement)*threshold)
+		}
+
+		logrus.WithFields(logrus.Fields{
+			"upstream_pubkey":   t.upstreamPubkey,
+			"threshold":         threshold,
+			"threshold_point":   thresholdPoint,
+			"current_usage":     currentUsage,
+			"current_increment": t.currentIncrement,
+			"total_allotment":   t.totalAllotment,
+		}).Info("Timer calculation details")
+
+		// Calculate remaining time until threshold
+		var duration time.Duration
+		if thresholdPoint > currentUsage {
+			duration = time.Duration(thresholdPoint-currentUsage) * time.Millisecond
+			logrus.WithFields(logrus.Fields{
+				"upstream_pubkey": t.upstreamPubkey,
+				"threshold":       threshold,
+				"duration_ms":     duration.Milliseconds(),
+			}).Debug("❗️ Setting timer for duration")
+		} else {
+			// We've already passed this threshold, skip it
+			logrus.WithFields(logrus.Fields{
+				"upstream_pubkey": t.upstreamPubkey,
+				"threshold":       threshold,
+				"threshold_point": thresholdPoint,
+				"current_usage":   currentUsage,
+			}).Info("❗️ Skipping threshold timer: already passed")
+			continue
+		}
+
+		timer := time.AfterFunc(duration, func(th float64) func() {
+			return func() {
+				t.handleThresholdReached(th)
+			}
+		}(threshold))
+
+		t.timers = append(t.timers, timer)
+
+		logrus.WithFields(logrus.Fields{
+			"upstream_pubkey":   t.upstreamPubkey,
+			"threshold":         threshold,
+			"threshold_point":   thresholdPoint,
+			"current_usage":     currentUsage,
+			"current_increment": t.currentIncrement,
+			"total_allotment":   t.totalAllotment,
+			"duration_ms":       duration.Milliseconds(),
+		}).Debug("Set up threshold timer")
+	}
+}
+
+// handleThresholdReached is called when a threshold timer fires
+func (t *TimeUsageTracker) handleThresholdReached(threshold float64) {
+	t.mu.RLock()
+	currentUsage := t.GetCurrentUsage()
+	upstreamPubkey := t.upstreamPubkey
+	totalAllotment := t.totalAllotment
+	t.mu.RUnlock()
+
+	logrus.WithFields(logrus.Fields{
+		"upstream_pubkey": upstreamPubkey,
+		"threshold":       threshold,
+		"current_usage":   currentUsage,
+		"total_allotment": totalAllotment,
+	}).Info("Time usage threshold reached, triggering renewal")
+
+	// Call the chandler's renewal handler
+	go func() {
+		err := t.chandler.HandleUpcomingRenewal(upstreamPubkey, currentUsage)
+		if err != nil {
+			logrus.WithFields(logrus.Fields{
+				"upstream_pubkey": upstreamPubkey,
+				"error":           err,
+			}).Error("Failed to handle upcoming renewal")
+		}
+	}()
+}
diff --git a/src/chandler/types.go b/src/chandler/types.go
new file mode 100644
index 0000000..30b6217
--- /dev/null
+++ b/src/chandler/types.go
@@ -0,0 +1,176 @@
+package chandler
+
+import (
+	"sync"
+	"time"
+
+	"github.com/OpenTollGate/tollgate-module-basic-go/src/tollgate_protocol"
+	"github.com/nbd-wtf/go-nostr"
+)
+
+// UpstreamTollgate represents a discovered upstream TollGate
+type UpstreamTollgate struct {
+	// Network interface information
+	InterfaceName string // e.g., "eth0", "wlan0"
+	MacAddress    string // MAC address of local interface
+	GatewayIP     string // IP address of the upstream gateway
+
+	// TollGate advertisement information
+	Advertisement *nostr.Event // Complete TollGate advertisement event (kind 10021)
+
+	// Discovery metadata
+	DiscoveredAt time.Time // When this TollGate was discovered
+}
+
+// ChandlerSession represents an active session with an upstream TollGate
+type ChandlerSession struct {
+	// Original upstream tollgate object (contains all network info)
+	UpstreamTollgate *UpstreamTollgate // Original upstream tollgate discovery object
+
+	// Customer identity for this session
+	CustomerPrivateKey string // Unique private key for this upstream connection
+
+	// Advertisement and pricing (extracted as single unit to maintain consistency)
+	Advertisement     *nostr.Event                         // Current advertisement (kind 10021)
+	AdvertisementInfo *tollgate_protocol.AdvertisementInfo // Extracted advertisement data
+	SelectedPricing   *tollgate_protocol.PricingOption     // Currently selected pricing option
+
+	// Session state
+	SessionEvent   *nostr.Event // Active session event (kind 1022)
+	TotalAllotment uint64       // Total allotment purchased
+
+	// Usage tracking
+	UsageTracker      UsageTrackerInterface // Active usage tracker
+	RenewalThresholds []float64             // Renewal thresholds (e.g., 0.8)
+	LastRenewalAt     time.Time             // Last renewal timestamp
+
+	// Session metadata
+	CreatedAt     time.Time     // Session creation time
+	LastPaymentAt time.Time     // Last payment timestamp
+	TotalSpent    uint64        // Total sats spent on this session
+	PaymentCount  int           // Number of payments made
+	Status        SessionStatus // Active, Paused, Expired, etc.
+
+	// Mutex for thread safety
+	mu sync.RWMutex
+}
+
+// SessionStatus represents the status of a session
+type SessionStatus int
+
+const (
+	SessionActive SessionStatus = iota
+	SessionPaused
+	SessionExpired
+	SessionError
+)
+
+// PaymentProposal represents a payment proposal for an upstream TollGate
+type PaymentProposal struct {
+	UpstreamPubkey     string                           // Target upstream TollGate
+	Steps              uint64                           // Number of steps to purchase
+	PricingOption      *tollgate_protocol.PricingOption // Selected pricing option
+	Reason             string                           // "initial", "renewal", "extension"
+	EstimatedAllotment uint64                           // Expected allotment
+}
+
+// ChandlerInterface defines the interface for the chandler module
+type ChandlerInterface interface {
+	// HandleUpstreamTollgate is called when Crowsnest discovers a new upstream TollGate
+	HandleUpstreamTollgate(upstream *UpstreamTollgate) error
+
+	// HandleDisconnect is called when a network interface goes down
+	HandleDisconnect(interfaceName string) error
+
+	// HandleUpcomingRenewal is called by UsageTracker when renewal threshold reached
+	HandleUpcomingRenewal(upstreamPubkey string, currentUsage uint64) error
+
+	// Management methods
+	GetActiveSessions() map[string]*ChandlerSession
+	GetSessionByPubkey(pubkey string) (*ChandlerSession, error)
+
+	// Control methods
+	PauseSession(pubkey string) error
+	ResumeSession(pubkey string) error
+	TerminateSession(pubkey string) error
+}
+
+// UsageTrackerInterface defines the interface for usage tracking
+type UsageTrackerInterface interface {
+	// Start monitoring usage for the given session
+	Start(session *ChandlerSession, chandler ChandlerInterface) error
+
+	// Stop monitoring and cleanup
+	Stop() error
+
+	// Get current usage amount
+	GetCurrentUsage() uint64
+
+	// Update usage amount (for external updates)
+	UpdateUsage(amount uint64) error
+
+	// Set renewal thresholds
+	SetRenewalThresholds(thresholds []float64) error
+
+	// sessionChanged is called when the session is updated
+	SessionChanged(session *ChandlerSession) error
+}
+
+// TimeUsageTracker tracks time-based usage
+type TimeUsageTracker struct {
+	upstreamPubkey   string
+	chandler         ChandlerInterface
+	startTime        time.Time
+	pausedTime       time.Duration
+	thresholds       []float64
+	timers           []*time.Timer
+	done             chan bool
+	totalAllotment   uint64
+	currentIncrement uint64
+	mu               sync.RWMutex
+}
+
+// DataUsageTracker tracks data-based usage
+type DataUsageTracker struct {
+	upstreamPubkey   string
+	chandler         ChandlerInterface
+	interfaceName    string
+	startBytes       uint64
+	currentBytes     uint64
+	thresholds       []float64
+	triggered        map[float64]bool
+	ticker           *time.Ticker
+	done             chan bool
+	totalAllotment   uint64
+	currentIncrement uint64
+	mu               sync.RWMutex
+}
+
+// ChandlerError represents errors specific to the chandler module
+type ChandlerError struct {
+	Type           ErrorType
+	Code           string
+	Message        string
+	Cause          error
+	UpstreamPubkey string
+	Context        map[string]interface{}
+}
+
+// ErrorType represents the type of chandler error
+type ErrorType int
+
+const (
+	ErrorTypeDiscovery ErrorType = iota
+	ErrorTypeTrust
+	ErrorTypeBudget
+	ErrorTypePayment
+	ErrorTypeSession
+	ErrorTypeUsageTracking
+)
+
+func (e *ChandlerError) Error() string {
+	if e.Cause != nil {
+		return e.Message + ": " + e.Cause.Error()
+	}
+	return e.Message
+}
diff --git a/src/config_manager/config_manager_config.go b/src/config_manager/config_manager_config.go
index 1f977ca..d5b9177 100644
--- a/src/config_manager/config_manager_config.go
+++ b/src/config_manager/config_manager_config.go
@@ -4,17 +4,21 @@ import (
 	"encoding/json"
 	"log"
 	"os"
+	"time"
 )
 
 // Config represents the main configuration for the Tollgate service.
 type Config struct {
 	ConfigVersion string              `json:"config_version"`
+	LogLevel      string              `json:"log_level"`
 	AcceptedMints []MintConfig        `json:"accepted_mints"`
 	ProfitShare   []ProfitShareConfig `json:"profit_share"`
 	StepSize      uint64              `json:"step_size"`
 	Metric        string              `json:"metric"`
 	Relays        []string            `json:"relays"`
 	ShowSetup     bool                `json:"show_setup"`
+	Crowsnest     CrowsnestConfig     `json:"crowsnest"`
+	Chandler      ChandlerConfig      `json:"chandler"`
 }
 
 // MintConfig holds configuration for a specific mint.
@@ -35,6 +39,59 @@ type ProfitShareConfig struct {
 	Identity string  `json:"identity"`
 }
 
+// CrowsnestConfig holds configuration for the crowsnest module
+type CrowsnestConfig struct {
+	// Probing settings
+	ProbeTimeout    time.Duration `json:"probe_timeout"`
+	ProbeRetryCount int           `json:"probe_retry_count"`
+	ProbeRetryDelay time.Duration `json:"probe_retry_delay"`
+
+	// Validation settings
+	RequireValidSignature bool `json:"require_valid_signature"`
+
+	// Interface filtering
+	IgnoreInterfaces []string `json:"ignore_interfaces"`
+	OnlyInterfaces   []string `json:"only_interfaces"`
+
+	// Discovery deduplication
+	DiscoveryTimeout time.Duration `json:"discovery_timeout"`
+}
+
+// ChandlerConfig holds configuration for the chandler module
+type ChandlerConfig struct {
+	// Simple budget settings
+	MaxPricePerMillisecond float64 `json:"max_price_per_millisecond"` // Max sats per ms (can be fractional)
+	MaxPricePerByte        float64 `json:"max_price_per_byte"`        // Max sats per byte (can be fractional)
+
+	// Trust settings
+	Trust TrustConfig `json:"trust"`
+
+	// Session settings
+	Sessions SessionConfig `json:"sessions"`
+
+	// Usage tracking settings
+	UsageTracking UsageTrackingConfig `json:"usage_tracking"`
+}
+
+// TrustConfig holds trust policy configuration
+type TrustConfig struct {
+	DefaultPolicy string   `json:"default_policy"` // "trust_all", "trust_none"
+	Allowlist     []string `json:"allowlist"`      // Trusted pubkeys
+	Blocklist     []string `json:"blocklist"`      // Blocked pubkeys
+}
+
+// SessionConfig holds session management configuration
+type SessionConfig struct {
+	DefaultRenewalThresholds               []float64 `json:"default_renewal_thresholds"`                // [0.8]
+	PreferredSessionIncrementsMilliseconds uint64    `json:"preferred_session_increments_milliseconds"` // Preferred increment for time sessions
+	PreferredSessionIncrementsBytes        uint64    `json:"preferred_session_increments_bytes"`        // Preferred increment for data sessions
+}
+
+// UsageTrackingConfig holds usage tracking configuration
+type UsageTrackingConfig struct {
+	DataMonitoringInterval time.Duration `json:"data_monitoring_interval"` // How often to check data usage
+}
+
 // LoadConfig loads and parses config.json.
 func LoadConfig(filePath string) (*Config, error) {
 	data, err := os.ReadFile(filePath)
@@ -67,7 +124,8 @@ func SaveConfig(filePath string, config *Config) error {
 // NewDefaultConfig creates a Config with default values.
 func NewDefaultConfig() *Config {
 	return &Config{
-		ConfigVersion: "v0.0.4",
+		ConfigVersion: "v0.0.5",
+		LogLevel:      "info",
 		AcceptedMints: []MintConfig{
 			{
 				URL:                     "https://mint.minibits.cash/Bitcoin",
@@ -108,6 +166,32 @@ func NewDefaultConfig() *Config {
 			"wss://nostr.mom",
 		},
 		ShowSetup: true,
+		Crowsnest: CrowsnestConfig{
+			ProbeTimeout:          10 * time.Second,
+			ProbeRetryCount:       3,
+			ProbeRetryDelay:       2 * time.Second,
+			RequireValidSignature: true,
+			IgnoreInterfaces:      []string{"lo", "docker0", "br-lan", "phy1-ap0", "phy0-ap0", "wlan0-ap", "wlan1-ap", "hostap0"},
+			OnlyInterfaces:        []string{},
+			DiscoveryTimeout:      300 * time.Second,
+		},
+		Chandler: ChandlerConfig{
+			MaxPricePerMillisecond: 0.002777777778,   // 10k sats/hr
+			MaxPricePerByte:        0.00003725782414, // 5k sats/gbit
+			Trust: TrustConfig{
+				DefaultPolicy: "trust_all",
+				Allowlist:     []string{},
+				Blocklist:     []string{},
+			},
+			Sessions: SessionConfig{
+				DefaultRenewalThresholds:               []float64{0.8},
+				PreferredSessionIncrementsMilliseconds: 20000,   // 1 minute
+				PreferredSessionIncrementsBytes:        1048576, // 1 MB
+			},
+			UsageTracking: UsageTrackingConfig{
+				DataMonitoringInterval: 500 * time.Millisecond,
+			},
+		},
 	}
 }
 
diff --git a/src/crowsnest/crowsnest.go b/src/crowsnest/crowsnest.go
new file mode 100644
index 0000000..97ecb3d
--- /dev/null
+++ b/src/crowsnest/crowsnest.go
@@ -0,0 +1,382 @@
+package crowsnest
+
+import (
+	"context"
+	"fmt"
+	"sync"
+	"time"
+
+	"github.com/OpenTollGate/tollgate-module-basic-go/src/chandler"
+	"github.com/OpenTollGate/tollgate-module-basic-go/src/config_manager"
+	"github.com/OpenTollGate/tollgate-module-basic-go/src/tollgate_protocol"
+	"github.com/sirupsen/logrus"
+)
+
+// crowsnest implements the Crowsnest interface
+type crowsnest struct {
+	config           *config_manager.CrowsnestConfig
+	configManager    *config_manager.ConfigManager
+	networkMonitor   NetworkMonitor
+	tollGateProber   TollGateProber
+	discoveryTracker DiscoveryTracker
+	chandler         chandler.ChandlerInterface
+
+	// Control channels
+	stopChan chan struct{}
+	wg       sync.WaitGroup
+	running  bool
+	mu       sync.RWMutex
+}
+
+// NewCrowsnest creates a new crowsnest instance
+func NewCrowsnest(configManager *config_manager.ConfigManager) (Crowsnest, error) {
+	if configManager == nil {
+		return nil, fmt.Errorf("config manager is required")
+	}
+
+	// Load configuration from config manager
+	mainConfig := configManager.GetConfig()
+	if mainConfig == nil {
+		return nil, fmt.Errorf("failed to get main configuration")
+	}
+
+	config := &mainConfig.Crowsnest
+
+	// Create components
+	networkMonitor := NewNetworkMonitor(config)
+	tollGateProber := NewTollGateProber(config)
+	discoveryTracker := NewDiscoveryTracker(config)
+
+	cs := &crowsnest{
+		config:           config,
+		configManager:    configManager,
+		networkMonitor:   networkMonitor,
+		tollGateProber:   tollGateProber,
+		discoveryTracker: discoveryTracker,
+		stopChan:         make(chan struct{}),
+	}
+
+	return cs, nil
+}
+
+// Start begins monitoring network changes and discovering TollGates
+func (cs *crowsnest) Start() error {
+	cs.mu.Lock()
+	defer cs.mu.Unlock()
+
+	if cs.running {
+		return fmt.Errorf("crowsnest is already running")
+	}
+
+	logger.Info("Starting Crowsnest network monitoring and TollGate discovery")
+
+	// Start network monitor
+	err := cs.networkMonitor.Start()
+	if err != nil {
+		return fmt.Errorf("failed to start network monitor: %w", err)
+	}
+
+	cs.running = true
+	cs.wg.Add(1)
+	go cs.eventLoop()
+
+	// Perform initial interface scan to auto-connect after startup/reboot
+	go cs.performInitialInterfaceScan()
+
+	logger.Info("Crowsnest started successfully")
+	return nil
+}
+
+// Stop stops the crowsnest monitoring
+func (cs *crowsnest) Stop() error {
+	cs.mu.Lock()
+	defer cs.mu.Unlock()
+
+	if !cs.running {
+		return nil
+	}
+
+	logger.Info("Stopping Crowsnest")
+
+	// Stop network monitor
+	err := cs.networkMonitor.Stop()
+	if err != nil {
+		logger.WithError(err).Error("Error stopping network monitor")
+	}
+
+	// Stop event loop
+	close(cs.stopChan)
+	cs.running = false
+	cs.wg.Wait()
+
+	// Cleanup discovery tracker
+	cs.discoveryTracker.Cleanup()
+
+	logger.Info("Crowsnest stopped successfully")
+	return nil
+}
+
+// SetChandler sets the chandler for upstream TollGate management
+func (cs *crowsnest) SetChandler(chandler chandler.ChandlerInterface) {
+	cs.mu.Lock()
+	defer cs.mu.Unlock()
+
+	cs.chandler = chandler
+	logger.Info("Chandler set for Crowsnest")
+}
+
+// eventLoop is the main event processing loop
+func (cs *crowsnest) eventLoop() {
+	defer cs.wg.Done()
+
+	logger.Info("Crowsnest event loop started")
+
+	for {
+		select {
+		case <-cs.stopChan:
+			logger.Info("Crowsnest event loop stopping")
+			return
+
+		case event := <-cs.networkMonitor.Events():
+			cs.handleNetworkEvent(event)
+		}
+	}
+}
+
+// handleNetworkEvent processes a network event
+func (cs *crowsnest) handleNetworkEvent(event NetworkEvent) {
+	logger.WithFields(logrus.Fields{
+		"event_type": cs.eventTypeToString(event.Type),
+		"interface":  event.InterfaceName,
+	}).Debug("Processing network event")
+
+	switch event.Type {
+	case EventInterfaceUp:
+		cs.handleInterfaceUp(event)
+	case EventInterfaceDown:
+		cs.handleInterfaceDown(event)
+	case EventAddressAdded:
+		cs.handleAddressAdded(event)
+	case EventAddressDeleted:
+		cs.handleAddressDeleted(event)
+	default:
+		logger.WithField("event_type", event.Type).Warn("Unhandled network event type")
+	}
+}
+
+// handleInterfaceUp handles interface up events
+func (cs *crowsnest) handleInterfaceUp(event NetworkEvent) {
+	if event.GatewayIP == "" {
+		logger.WithField("interface", event.InterfaceName).Debug("Interface is up but no gateway found")
+		return
+	}
+
+	logger.WithFields(logrus.Fields{
+		"interface": event.InterfaceName,
+		"gateway":   event.GatewayIP,
+	}).Debug("Interface is up with gateway - attempting TollGate discovery")
+
+	// Attempt TollGate discovery asynchronously
+	go cs.attemptTollGateDiscovery(event.InterfaceName, event.InterfaceInfo.MacAddress, event.GatewayIP)
+}
+
+// handleInterfaceDown handles interface down events
+func (cs *crowsnest) handleInterfaceDown(event NetworkEvent) {
+	logger.WithField("interface", event.InterfaceName).Info("Interface is down - cleaning up and notifying chandler")
+
+	// Cancel any active probes for this interface
+	cs.tollGateProber.CancelProbesForInterface(event.InterfaceName)
+
+	// Clear discovery attempts for this interface (including successful ones)
+	// This allows re-discovery when the interface comes back up
+	cs.discoveryTracker.ClearInterface(event.InterfaceName)
+
+	// Notify chandler of disconnect
+	if cs.chandler != nil {
+		err := cs.chandler.HandleDisconnect(event.InterfaceName)
+		if err != nil {
+			logger.WithFields(logrus.Fields{
+				"interface": event.InterfaceName,
+				"error":     err,
+			}).Error("Error notifying chandler of disconnect")
+		}
+	} else {
+		logger.WithField("interface", event.InterfaceName).Debug("No chandler set - cannot notify of disconnect")
+	}
+}
+
+// handleAddressAdded handles address added events
+func (cs *crowsnest) handleAddressAdded(event NetworkEvent) {
+	// For address changes, we might want to re-check the gateway
+	if event.GatewayIP != "" {
+		logger.WithFields(logrus.Fields{
+			"interface": event.InterfaceName,
+			"gateway":   event.GatewayIP,
+		}).Debug("Address added to interface with gateway - checking for TollGate")
+		go cs.attemptTollGateDiscovery(event.InterfaceName, event.InterfaceInfo.MacAddress, event.GatewayIP)
+	}
+}
+
+// handleAddressDeleted handles address deleted events
+func (cs *crowsnest) handleAddressDeleted(event NetworkEvent) {
+	logger.WithField("interface", event.InterfaceName).Debug("Address deleted from interface - checking for TollGate disconnection")
+
+	// When an address is deleted, this might indicate a disconnection
+	// Check if we had a successful TollGate connection on this interface
+	// and treat address deletion as a potential disconnection
+
+	// Cancel any active probes for this interface
+	cs.tollGateProber.CancelProbesForInterface(event.InterfaceName)
+
+	// Clear discovery attempts for this interface to allow re-discovery
+	cs.discoveryTracker.ClearInterface(event.InterfaceName)
+
+	// Notify chandler of potential disconnect
+	if cs.chandler != nil {
+		err := cs.chandler.HandleDisconnect(event.InterfaceName)
+		if err != nil {
+			logger.WithFields(logrus.Fields{
+				"interface": event.InterfaceName,
+				"error":     err,
+			}).Error("Error notifying chandler of disconnect")
+		}
+	}
+}
+
+// attemptTollGateDiscovery attempts to discover a TollGate on the given gateway
+func (cs *crowsnest) attemptTollGateDiscovery(interfaceName, macAddress, gatewayIP string) {
+	// Check if we should attempt discovery (prevents concurrent attempts)
+	if !cs.discoveryTracker.ShouldAttemptDiscovery(interfaceName, gatewayIP) {
+		logger.WithFields(logrus.Fields{
+			"interface": interfaceName,
+			"gateway":   gatewayIP,
+		}).Debug("Skipping discovery - recently attempted or already successful")
+		return
+	}
+
+	// Record the discovery attempt as pending immediately to prevent concurrent attempts
+	cs.discoveryTracker.RecordDiscovery(interfaceName, gatewayIP, DiscoveryResultPending)
+
+	// Create a context for this discovery attempt
+	ctx, cancel := context.WithTimeout(context.Background(), cs.config.DiscoveryTimeout)
+	defer cancel()
+
+	// Probe the gateway with context
+	logger.WithFields(logrus.Fields{
+		"gateway":   gatewayIP,
+		"interface": interfaceName,
+	}).Debug("Probing gateway for TollGate advertisement")
+
+	data, err := cs.tollGateProber.ProbeGatewayWithContext(ctx, interfaceName, gatewayIP)
+	if err != nil {
+		logger.WithFields(logrus.Fields{
+			"gateway": gatewayIP,
+			"error":   err,
+		}).Error("Failed to probe gateway")
+		cs.discoveryTracker.RecordDiscovery(interfaceName, gatewayIP, DiscoveryResultError)
+		return
+	}
+
+	// Validate the advertisement using tollgate_protocol
+	event, err := tollgate_protocol.ValidateAdvertisementFromBytes(data)
+	if err != nil {
+		logger.WithFields(logrus.Fields{
+			"gateway": gatewayIP,
+			"error":   err,
+		}).Warn("Invalid TollGate advertisement from gateway")
+		cs.discoveryTracker.RecordDiscovery(interfaceName, gatewayIP, DiscoveryResultValidationFailed)
+		return
+	}
+
+	logger.WithFields(logrus.Fields{
+		"gateway":    gatewayIP,
+		"public_key": event.PubKey,
+	}).Info("Valid TollGate advertisement discovered")
+
+	// Create UpstreamTollgate object
+	upstream := &chandler.UpstreamTollgate{
+		InterfaceName: interfaceName,
+		MacAddress:    macAddress,
+		GatewayIP:     gatewayIP,
+		Advertisement: event,
+		DiscoveredAt:  time.Now(),
+	}
+
+	// Record successful discovery
+	cs.discoveryTracker.RecordDiscovery(interfaceName, gatewayIP, DiscoveryResultSuccess)
+
+	// Hand off to chandler
+	if cs.chandler != nil {
+		err = cs.chandler.HandleUpstreamTollgate(upstream)
+		if err != nil {
+			logger.WithError(err).Error("Error handing off upstream TollGate to chandler")
+		} else {
+			logger.WithFields(logrus.Fields{
+				"interface": interfaceName,
+				"gateway":   gatewayIP,
+			}).Debug("Successfully handed off upstream TollGate to chandler")
+		}
+	} else {
+		logger.WithFields(logrus.Fields{
+			"interface": interfaceName,
+			"gateway":   gatewayIP,
+		}).Debug("No chandler set - cannot hand off upstream TollGate")
+	}
+}
+
+// eventTypeToString converts event type to string for logging
+func (cs *crowsnest) eventTypeToString(eventType EventType) string {
+	switch eventType {
+	case EventInterfaceUp:
+		return "InterfaceUp"
+	case EventInterfaceDown:
+		return "InterfaceDown"
+	case EventRouteDeleted:
+		return "RouteDeleted"
+	case EventAddressAdded:
+		return "AddressAdded"
+	case EventAddressDeleted:
+		return "AddressDeleted"
+	default:
+		return fmt.Sprintf("Unknown(%d)", eventType)
+	}
+}
+
+// performInitialInterfaceScan scans existing network interfaces on startup
+func (cs *crowsnest) performInitialInterfaceScan() {
+	// Small delay to allow the system to fully initialize
+	time.Sleep(2 * time.Second)
+
+	logger.Info("Performing initial interface scan for TollGate auto-discovery")
+
+	// Get current network interfaces
+	interfaces, err := cs.networkMonitor.GetCurrentInterfaces()
+	if err != nil {
+		logger.WithError(err).Error("Error getting current interfaces during startup scan")
+		return
+	}
+
+	// Check each interface that is up and has IP addresses
+	for _, iface := range interfaces {
+		if !iface.IsUp || len(iface.IPAddresses) == 0 {
+			continue
+		}
+
+		// Get gateway for this interface
+		gatewayIP := cs.networkMonitor.GetGatewayForInterface(iface.Name)
+		if gatewayIP == "" {
+			logger.WithField("interface", iface.Name).Debug("Startup scan: Interface is up but no gateway found")
+			continue
+		}
+
+		logger.WithFields(logrus.Fields{
+			"interface": iface.Name,
+			"gateway":   gatewayIP,
+		}).Info("Startup scan: Found interface with gateway - attempting TollGate discovery")
+
+		// Attempt TollGate discovery asynchronously
+		go cs.attemptTollGateDiscovery(iface.Name, iface.MacAddress, gatewayIP)
+	}
+
+	logger.Info("Initial interface scan completed")
+}
diff --git a/src/crowsnest/discovery_tracker.go b/src/crowsnest/discovery_tracker.go
new file mode 100644
index 0000000..80480f8
--- /dev/null
+++ b/src/crowsnest/discovery_tracker.go
@@ -0,0 +1,86 @@
+package crowsnest
+
+import (
+	"sync"
+	"time"
+
+	"github.com/OpenTollGate/tollgate-module-basic-go/src/config_manager"
+)
+
+// simpleDiscoveryTracker implements basic deduplication with timestamps and results
+type simpleDiscoveryTracker struct {
+	config       *config_manager.CrowsnestConfig
+	lastAttempts map[string]DiscoveryAttempt
+	mu           sync.RWMutex
+}
+
+// NewDiscoveryTracker creates a new simple discovery tracker
+func NewDiscoveryTracker(config *config_manager.CrowsnestConfig) DiscoveryTracker {
+	return &simpleDiscoveryTracker{
+		config:       config,
+		lastAttempts: make(map[string]DiscoveryAttempt),
+	}
+}
+
+// ShouldAttemptDiscovery checks if discovery should be attempted based on previous results
+func (dt *simpleDiscoveryTracker) ShouldAttemptDiscovery(interfaceName, gatewayIP string) bool {
+	dt.mu.RLock()
+	defer dt.mu.RUnlock()
+
+	key := interfaceName + ":" + gatewayIP
+	lastAttempt, exists := dt.lastAttempts[key]
+
+	if !exists {
+		return true // Never attempted before
+	}
+
+	// If it was successfully discovered as a TollGate, NEVER retry
+	// This is the final state - it's been handed off to the chandler
+	if lastAttempt.Result == DiscoveryResultSuccess {
+		return false
+	}
+
+	// If discovery is currently pending, don't start another attempt
+	if lastAttempt.Result == DiscoveryResultPending {
+		// Allow retry only if pending attempt is taking too long (timeout)
+		return time.Since(lastAttempt.AttemptTime) > dt.config.ProbeTimeout*2
+	}
+
+	// For other results (errors, validation failures), allow retry after discovery timeout
+	return time.Since(lastAttempt.AttemptTime) > dt.config.DiscoveryTimeout
+}
+
+// RecordDiscovery records when a discovery attempt was made with its result
+func (dt *simpleDiscoveryTracker) RecordDiscovery(interfaceName, gatewayIP string, result DiscoveryResult) {
+	dt.mu.Lock()
+	defer dt.mu.Unlock()
+
+	key := interfaceName + ":" + gatewayIP
+	dt.lastAttempts[key] = DiscoveryAttempt{
+		InterfaceName: interfaceName,
+		GatewayIP:     gatewayIP,
+		AttemptTime:   time.Now(),
+		Result:        result,
+	}
+}
+
+// ClearInterface removes all discovery attempts for a specific interface
+func (dt *simpleDiscoveryTracker) ClearInterface(interfaceName string) {
+	dt.mu.Lock()
+	defer dt.mu.Unlock()
+
+	// Remove all attempts for this interface
+	for key, attempt := range dt.lastAttempts {
+		if attempt.InterfaceName == interfaceName {
+			delete(dt.lastAttempts, key)
+		}
+	}
+}
+
+// Cleanup clears all recorded attempts
+func (dt *simpleDiscoveryTracker) Cleanup() {
+	dt.mu.Lock()
+	defer dt.mu.Unlock()
+
+	dt.lastAttempts = make(map[string]DiscoveryAttempt)
+}
diff --git a/src/crowsnest/go.mod b/src/crowsnest/go.mod
new file mode 100644
index 0000000..3ea5e4b
--- /dev/null
+++ b/src/crowsnest/go.mod
@@ -0,0 +1,48 @@
+module github.com/OpenTollGate/tollgate-module-basic-go/src/crowsnest
+
+go 1.24.2
+
+toolchain go1.24.5
+
+require (
+	github.com/OpenTollGate/tollgate-module-basic-go/src/chandler v0.0.0-00010101000000-000000000000
+	github.com/OpenTollGate/tollgate-module-basic-go/src/config_manager v0.0.0-00010101000000-000000000000
+	github.com/OpenTollGate/tollgate-module-basic-go/src/tollgate_protocol v0.0.0-00010101000000-000000000000
+	github.com/vishvananda/netlink v1.3.1
+)
+
+require (
+	github.com/ImVexed/fasturl v0.0.0-20230304231329-4e41488060f3 // indirect
+	github.com/btcsuite/btcd/btcec/v2 v2.3.4 // indirect
+	github.com/btcsuite/btcd/chaincfg/chainhash v1.1.0 // indirect
+	github.com/bytedance/sonic v1.13.2 // indirect
+	github.com/bytedance/sonic/loader v0.2.4 // indirect
+	github.com/cloudwego/base64x v0.1.5 // indirect
+	github.com/coder/websocket v1.8.13 // indirect
+	github.com/decred/dcrd/crypto/blake256 v1.1.0 // indirect
+	github.com/decred/dcrd/dcrec/secp256k1/v4 v4.4.0 // indirect
+	github.com/hashicorp/go-version v1.7.0 // indirect
+	github.com/josharian/intern v1.0.0 // indirect
+	github.com/json-iterator/go v1.1.12 // indirect
+	github.com/klauspost/cpuid/v2 v2.2.10 // indirect
+	github.com/mailru/easyjson v0.9.0 // indirect
+	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
+	github.com/modern-go/reflect2 v1.0.2 // indirect
+	github.com/nbd-wtf/go-nostr v0.51.10 // indirect
+	github.com/puzpuzpuz/xsync/v3 v3.5.1 // indirect
+	github.com/sirupsen/logrus v1.9.3 // indirect
+	github.com/tidwall/gjson v1.18.0 // indirect
+	github.com/tidwall/match v1.1.1 // indirect
+	github.com/tidwall/pretty v1.2.1 // indirect
+	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
+	github.com/vishvananda/netns v0.0.5 // indirect
+	golang.org/x/arch v0.17.0 // indirect
+	golang.org/x/exp v0.0.0-20250506013437-ce4c2cf36ca6 // indirect
+	golang.org/x/sys v0.33.0 // indirect
+)
+
+replace github.com/OpenTollGate/tollgate-module-basic-go/src/config_manager => ../config_manager
+
+replace github.com/OpenTollGate/tollgate-module-basic-go/src/tollgate_protocol => ../tollgate_protocol
+
+replace github.com/OpenTollGate/tollgate-module-basic-go/src/chandler => ../chandler
diff --git a/src/crowsnest/go.sum b/src/crowsnest/go.sum
new file mode 100644
index 0000000..548b90f
--- /dev/null
+++ b/src/crowsnest/go.sum
@@ -0,0 +1,90 @@
+github.com/ImVexed/fasturl v0.0.0-20230304231329-4e41488060f3 h1:ClzzXMDDuUbWfNNZqGeYq4PnYOlwlOVIvSyNaIy0ykg=
+github.com/ImVexed/fasturl v0.0.0-20230304231329-4e41488060f3/go.mod h1:we0YA5CsBbH5+/NUzC/AlMmxaDtWlXeNsqrwXjTzmzA=
+github.com/btcsuite/btcd/btcec/v2 v2.3.4 h1:3EJjcN70HCu/mwqlUsGK8GcNVyLVxFDlWurTXGPFfiQ=
+github.com/btcsuite/btcd/btcec/v2 v2.3.4/go.mod h1:zYzJ8etWJQIv1Ogk7OzpWjowwOdXY1W/17j2MW85J04=
+github.com/btcsuite/btcd/chaincfg/chainhash v1.1.0 h1:59Kx4K6lzOW5w6nFlA0v5+lk/6sjybR934QNHSJZPTQ=
+github.com/btcsuite/btcd/chaincfg/chainhash v1.1.0/go.mod h1:7SFka0XMvUgj3hfZtydOrQY2mwhPclbT2snogU7SQQc=
+github.com/bytedance/sonic v1.13.2 h1:8/H1FempDZqC4VqjptGo14QQlJx8VdZJegxs6wwfqpQ=
+github.com/bytedance/sonic v1.13.2/go.mod h1:o68xyaF9u2gvVBuGHPlUVCy+ZfmNNO5ETf1+KgkJhz4=
+github.com/bytedance/sonic/loader v0.1.1/go.mod h1:ncP89zfokxS5LZrJxl5z0UJcsk4M4yY2JpfqGeCtNLU=
+github.com/bytedance/sonic/loader v0.2.4 h1:ZWCw4stuXUsn1/+zQDqeE7JKP+QO47tz7QCNan80NzY=
+github.com/bytedance/sonic/loader v0.2.4/go.mod h1:N8A3vUdtUebEY2/VQC0MyhYeKUFosQU6FxH2JmUe6VI=
+github.com/cloudwego/base64x v0.1.5 h1:XPciSp1xaq2VCSt6lF0phncD4koWyULpl5bUxbfCyP4=
+github.com/cloudwego/base64x v0.1.5/go.mod h1:0zlkT4Wn5C6NdauXdJRhSKRlJvmclQ1hhJgA0rcu/8w=
+github.com/cloudwego/iasm v0.2.0/go.mod h1:8rXZaNYT2n95jn+zTI1sDr+IgcD2GVs0nlbbQPiEFhY=
+github.com/coder/websocket v1.8.13 h1:f3QZdXy7uGVz+4uCJy2nTZyM0yTBj8yANEHhqlXZ9FE=
+github.com/coder/websocket v1.8.13/go.mod h1:LNVeNrXQZfe5qhS9ALED3uA+l5pPqvwXg3CKoDBB2gs=
+github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
+github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
+github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
+github.com/decred/dcrd/crypto/blake256 v1.1.0 h1:zPMNGQCm0g4QTY27fOCorQW7EryeQ/U0x++OzVrdms8=
+github.com/decred/dcrd/crypto/blake256 v1.1.0/go.mod h1:2OfgNZ5wDpcsFmHmCK5gZTPcCXqlm2ArzUIkw9czNJo=
+github.com/decred/dcrd/dcrec/secp256k1/v4 v4.4.0 h1:NMZiJj8QnKe1LgsbDayM4UoHwbvwDRwnI3hwNaAHRnc=
+github.com/decred/dcrd/dcrec/secp256k1/v4 v4.4.0/go.mod h1:ZXNYxsqcloTdSy/rNShjYzMhyjf0LaoftYK0p+A3h40=
+github.com/dvyukov/go-fuzz v0.0.0-20200318091601-be3528f3a813/go.mod h1:11Gm+ccJnvAhCNLlf5+cS9KjtbaD5I5zaZpFMsTHWTw=
+github.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=
+github.com/hashicorp/go-version v1.7.0 h1:5tqGy27NaOTB8yJKUZELlFAS/LTKJkrmONwQKeRZfjY=
+github.com/hashicorp/go-version v1.7.0/go.mod h1:fltr4n8CU8Ke44wwGCBoEymUuxUHl09ZGVZPK5anwXA=
+github.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=
+github.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=
+github.com/json-iterator/go v1.1.12 h1:PV8peI4a0ysnczrg+LtxykD8LfKY9ML6u2jnxaEnrnM=
+github.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=
+github.com/klauspost/cpuid/v2 v2.0.9/go.mod h1:FInQzS24/EEf25PyTYn52gqo7WaD8xa0213Md/qVLRg=
+github.com/klauspost/cpuid/v2 v2.2.10 h1:tBs3QSyvjDyFTq3uoc/9xFpCuOsJQFNPiAhYdw2skhE=
+github.com/klauspost/cpuid/v2 v2.2.10/go.mod h1:hqwkgyIinND0mEev00jJYCxPNVRVXFQeu1XKlok6oO0=
+github.com/knz/go-libedit v1.10.1/go.mod h1:MZTVkCWyz0oBc7JOWP3wNAzd002ZbM/5hgShxwh4x8M=
+github.com/mailru/easyjson v0.9.0 h1:PrnmzHw7262yW8sTBwxi1PdJA3Iw/EKBa8psRf7d9a4=
+github.com/mailru/easyjson v0.9.0/go.mod h1:1+xMtQp2MRNVL/V1bOzuP3aP8VNwRW55fQUto+XFtTU=
+github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
+github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=
+github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
+github.com/modern-go/reflect2 v1.0.2 h1:xBagoLtFs94CBntxluKeaWgTMpvLxC4ur3nMaC9Gz0M=
+github.com/modern-go/reflect2 v1.0.2/go.mod h1:yWuevngMOJpCy52FWWMvUC8ws7m/LJsjYzDa0/r8luk=
+github.com/nbd-wtf/go-nostr v0.51.10 h1:MxyN/bRNqdeLbiN9lODbXduLRkYwy7SDTm73uGrsdU4=
+github.com/nbd-wtf/go-nostr v0.51.10/go.mod h1:IF30/Cm4AS90wd1GjsFJbBqq7oD1txo+2YUFYXqK3Nc=
+github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
+github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
+github.com/puzpuzpuz/xsync/v3 v3.5.1 h1:GJYJZwO6IdxN/IKbneznS6yPkVC+c3zyY/j19c++5Fg=
+github.com/puzpuzpuz/xsync/v3 v3.5.1/go.mod h1:VjzYrABPabuM4KyBh1Ftq6u8nhwY5tBPKP9jpmh0nnA=
+github.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=
+github.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=
+github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
+github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
+github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
+github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
+github.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
+github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
+github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
+github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
+github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
+github.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=
+github.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
+github.com/tidwall/gjson v1.18.0 h1:FIDeeyB800efLX89e5a8Y0BNH+LOngJyGrIWxG2FKQY=
+github.com/tidwall/gjson v1.18.0/go.mod h1:/wbyibRr2FHMks5tjHJ5F8dMZh3AcwJEMf5vlfC0lxk=
+github.com/tidwall/match v1.1.1 h1:+Ho715JplO36QYgwN9PGYNhgZvoUSc9X2c80KVTi+GA=
+github.com/tidwall/match v1.1.1/go.mod h1:eRSPERbgtNPcGhD8UCthc6PmLEQXEWd3PRB5JTxsfmM=
+github.com/tidwall/pretty v1.2.0/go.mod h1:ITEVvHYasfjBbM0u2Pg8T2nJnzm8xPwvNhhsoaGGjNU=
+github.com/tidwall/pretty v1.2.1 h1:qjsOFOWWQl+N3RsoF5/ssm1pHmJJwhjlSbZ51I6wMl4=
+github.com/tidwall/pretty v1.2.1/go.mod h1:ITEVvHYasfjBbM0u2Pg8T2nJnzm8xPwvNhhsoaGGjNU=
+github.com/twitchyliquid64/golang-asm v0.15.1 h1:SU5vSMR7hnwNxj24w34ZyCi/FmDZTkS4MhqMhdFk5YI=
+github.com/twitchyliquid64/golang-asm v0.15.1/go.mod h1:a1lVb/DtPvCB8fslRZhAngC2+aY1QWCk3Cedj/Gdt08=
+github.com/vishvananda/netlink v1.3.1 h1:3AEMt62VKqz90r0tmNhog0r/PpWKmrEShJU0wJW6bV0=
+github.com/vishvananda/netlink v1.3.1/go.mod h1:ARtKouGSTGchR8aMwmkzC0qiNPrrWO5JS/XMVl45+b4=
+github.com/vishvananda/netns v0.0.5 h1:DfiHV+j8bA32MFM7bfEunvT8IAqQ/NzSJHtcmW5zdEY=
+github.com/vishvananda/netns v0.0.5/go.mod h1:SpkAiCQRtJ6TvvxPnOSyH3BMl6unz3xZlaprSwhNNJM=
+golang.org/x/arch v0.17.0 h1:4O3dfLzd+lQewptAHqjewQZQDyEdejz3VwgeYwkZneU=
+golang.org/x/arch v0.17.0/go.mod h1:bdwinDaKcfZUGpH09BB7ZmOfhalA8lQdzl62l8gGWsk=
+golang.org/x/exp v0.0.0-20250506013437-ce4c2cf36ca6 h1:y5zboxd6LQAqYIhHnB48p0ByQ/GnQx2BE33L8BOHQkI=
+golang.org/x/exp v0.0.0-20250506013437-ce4c2cf36ca6/go.mod h1:U6Lno4MTRCDY+Ba7aCcauB9T60gsv5s4ralQzP72ZoQ=
+golang.org/x/net v0.37.0 h1:1zLorHbz+LYj7MQlSf1+2tPIIgibq2eL5xkrGk6f+2c=
+golang.org/x/net v0.37.0/go.mod h1:ivrbrMbzFq5J41QOQh0siUuly180yBYtLp+CKbEaFx8=
+golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+golang.org/x/sys v0.2.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+golang.org/x/sys v0.10.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+golang.org/x/sys v0.33.0 h1:q3i8TbbEz+JRD9ywIRlyRAQbM0qF7hu24q3teo2hbuw=
+golang.org/x/sys v0.33.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
+gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
+gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
+gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
+gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
+nullprogram.com/x/optparse v1.0.0/go.mod h1:KdyPE+Igbe0jQUrVfMqDMeJQIJZEuyV7pjYmp6pbG50=
diff --git a/src/crowsnest/interfaces.go b/src/crowsnest/interfaces.go
new file mode 100644
index 0000000..5b9da55
--- /dev/null
+++ b/src/crowsnest/interfaces.go
@@ -0,0 +1,38 @@
+package crowsnest
+
+import (
+	"context"
+
+	"github.com/OpenTollGate/tollgate-module-basic-go/src/chandler"
+)
+
+// Crowsnest defines the main interface for the crowsnest module
+type Crowsnest interface {
+	Start() error
+	Stop() error
+	SetChandler(chandler chandler.ChandlerInterface)
+}
+
+// NetworkMonitor defines the interface for network monitoring
+type NetworkMonitor interface {
+	Start() error
+	Stop() error
+	Events() <-chan NetworkEvent
+	GetCurrentInterfaces() ([]*InterfaceInfo, error)
+	GetGatewayForInterface(interfaceName string) string
+}
+
+// TollGateProber defines the interface for probing TollGate advertisements
+type TollGateProber interface {
+	ProbeGatewayWithContext(ctx context.Context, interfaceName, gatewayIP string) ([]byte, error)
+	CancelProbesForInterface(interfaceName string)
+	TriggerCaptivePortalSession(ctx context.Context, gatewayIP string) error
+}
+
+// DiscoveryTracker defines the interface for tracking discovery attempts
+type DiscoveryTracker interface {
+	ShouldAttemptDiscovery(interfaceName, gatewayIP string) bool
+	RecordDiscovery(interfaceName, gatewayIP string, result DiscoveryResult)
+	ClearInterface(interfaceName string)
+	Cleanup()
+}
diff --git a/src/crowsnest/logger.go b/src/crowsnest/logger.go
new file mode 100644
index 0000000..1a60d99
--- /dev/null
+++ b/src/crowsnest/logger.go
@@ -0,0 +1,6 @@
+package crowsnest
+
+import "github.com/sirupsen/logrus"
+
+// Module-level logger with pre-configured module field
+var logger = logrus.WithField("module", "crowsnest")
diff --git a/src/crowsnest/network_monitor.go b/src/crowsnest/network_monitor.go
new file mode 100644
index 0000000..754d664
--- /dev/null
+++ b/src/crowsnest/network_monitor.go
@@ -0,0 +1,512 @@
+//go:build linux
+// +build linux
+
+package crowsnest
+
+import (
+	"fmt"
+	"net"
+	"strings"
+	"sync"
+	"time"
+
+	"github.com/OpenTollGate/tollgate-module-basic-go/src/config_manager"
+	"github.com/sirupsen/logrus"
+	"github.com/vishvananda/netlink"
+)
+
+// networkMonitor implements the NetworkMonitor interface using event-driven netlink subscriptions
+type networkMonitor struct {
+	config        *config_manager.CrowsnestConfig
+	events        chan NetworkEvent
+	stopChan      chan struct{}
+	wg            sync.WaitGroup
+	running       bool
+	mu            sync.RWMutex
+	lastEventTime map[string]time.Time // Track last event time per interface
+	eventMutex    sync.RWMutex         // Protect lastEventTime map
+}
+
+// NewNetworkMonitor creates a new event-driven network monitor
+func NewNetworkMonitor(config *config_manager.CrowsnestConfig) NetworkMonitor {
+	return &networkMonitor{
+		config:        config,
+		events:        make(chan NetworkEvent, 100),
+		stopChan:      make(chan struct{}),
+		lastEventTime: make(map[string]time.Time),
+	}
+}
+
+// Start begins monitoring network changes using netlink subscriptions
+func (nm *networkMonitor) Start() error {
+	nm.mu.Lock()
+	defer nm.mu.Unlock()
+
+	if nm.running {
+		return fmt.Errorf("network monitor is already running")
+	}
+
+	logger.Info("Starting event-driven network monitor")
+
+	nm.running = true
+	nm.wg.Add(2) // One for link updates, one for address updates
+
+	// Start link monitoring
+	go nm.monitorLinkChanges()
+
+	// Start address monitoring
+	go nm.monitorAddressChanges()
+
+	return nil
+}
+
+// Stop stops the network monitor
+func (nm *networkMonitor) Stop() error {
+	nm.mu.Lock()
+	defer nm.mu.Unlock()
+
+	if !nm.running {
+		return nil
+	}
+
+	logger.Info("Stopping network monitor")
+
+	close(nm.stopChan)
+	nm.running = false
+	nm.wg.Wait()
+	close(nm.events)
+
+	return nil
+}
+
+// Events returns the channel for network events
+func (nm *networkMonitor) Events() <-chan NetworkEvent {
+	return nm.events
+}
+
+// monitorLinkChanges monitors network interface link changes (up/down)
+func (nm *networkMonitor) monitorLinkChanges() {
+	defer nm.wg.Done()
+
+	// Subscribe to network link updates
+	updates := make(chan netlink.LinkUpdate)
+	done := make(chan struct{})
+
+	// Subscribe to link updates
+	if err := netlink.LinkSubscribe(updates, done); err != nil {
+		logger.WithError(err).Error("Failed to subscribe to link updates")
+		return
+	}
+
+	logger.Info("Monitoring network interface link changes...")
+
+	for {
+		select {
+		case <-nm.stopChan:
+			close(done)
+			return
+		case update := <-updates:
+			nm.handleLinkUpdate(update)
+		}
+	}
+}
+
+// monitorAddressChanges monitors IP address changes on interfaces
+func (nm *networkMonitor) monitorAddressChanges() {
+	defer nm.wg.Done()
+
+	// Subscribe to address updates
+	updates := make(chan netlink.AddrUpdate)
+	done := make(chan struct{})
+
+	// Subscribe to address updates
+	if err := netlink.AddrSubscribe(updates, done); err != nil {
+		logger.WithError(err).Error("Failed to subscribe to address updates")
+		return
+	}
+
+	logger.Info("Monitoring network interface address changes...")
+
+	for {
+		select {
+		case <-nm.stopChan:
+			close(done)
+			return
+		case update := <-updates:
+			nm.handleAddressUpdate(update)
+		}
+	}
+}
+
+// handleLinkUpdate processes a network link update
+func (nm *networkMonitor) handleLinkUpdate(update netlink.LinkUpdate) {
+	link := update.Link
+	if link == nil {
+		return
+	}
+
+	attrs := link.Attrs()
+	if attrs == nil {
+		return
+	}
+
+	interfaceName := attrs.Name
+
+	// Check if we should monitor this interface
+	if !nm.shouldMonitorInterface(interfaceName) {
+		return
+	}
+
+	// Determine if interface is up or down
+	isUp := attrs.Flags&net.FlagUp != 0
+
+	// Create interface info
+	interfaceInfo := &InterfaceInfo{
+		Name:           interfaceName,
+		MacAddress:     attrs.HardwareAddr.String(),
+		IsUp:           isUp,
+		IsLoopback:     attrs.Flags&net.FlagLoopback != 0,
+		IsPointToPoint: attrs.Flags&net.FlagPointToPoint != 0,
+	}
+
+	// Get IP addresses for the interface
+	addrs, err := netlink.AddrList(link, netlink.FAMILY_ALL)
+	if err == nil {
+		for _, addr := range addrs {
+			interfaceInfo.IPAddresses = append(interfaceInfo.IPAddresses, addr.IP.String())
+		}
+	}
+
+	// Get gateway if interface is up
+	var gatewayIP string
+	if isUp {
+		gatewayIP = nm.getGatewayForInterface(interfaceName)
+	}
+
+	// Determine event type
+	eventType := EventInterfaceUp
+	if !isUp {
+		eventType = EventInterfaceDown
+	}
+
+	// Create and send event
+	event := NetworkEvent{
+		Type:          eventType,
+		InterfaceName: interfaceName,
+		InterfaceInfo: interfaceInfo,
+		GatewayIP:     gatewayIP,
+		Timestamp:     time.Now(),
+	}
+
+	nm.sendEvent(event)
+
+	// Log the change
+	if isUp {
+		logger.WithFields(logrus.Fields{
+			"interface": interfaceName,
+			"mac":       attrs.HardwareAddr.String(),
+			"gateway":   gatewayIP,
+		}).Debug("Interface is UP")
+	} else {
+		logger.WithField("interface", interfaceName).Debug("Interface is DOWN")
+	}
+}
+
+// handleAddressUpdate processes an IP address update
+func (nm *networkMonitor) handleAddressUpdate(update netlink.AddrUpdate) {
+	// Get the link for this address update
+	link, err := netlink.LinkByIndex(update.LinkIndex)
+	if err != nil {
+		logger.WithFields(logrus.Fields{
+			"link_index": update.LinkIndex,
+			"error":      err,
+		}).Error("Error getting link by index")
+		return
+	}
+
+	attrs := link.Attrs()
+	interfaceName := attrs.Name
+
+	// Check if we should monitor this interface
+	if !nm.shouldMonitorInterface(interfaceName) {
+		return
+	}
+
+	// Create interface info
+	interfaceInfo := &InterfaceInfo{
+		Name:       interfaceName,
+		MacAddress: attrs.HardwareAddr.String(),
+		IsUp:       attrs.Flags&net.FlagUp != 0,
+	}
+
+	// Get all current IP addresses for the interface
+	addrs, err := netlink.AddrList(link, netlink.FAMILY_ALL)
+	if err == nil {
+		for _, addr := range addrs {
+			interfaceInfo.IPAddresses = append(interfaceInfo.IPAddresses, addr.IP.String())
+		}
+	}
+
+	// Determine event type based on whether address was added or deleted
+	eventType := EventAddressAdded
+	if update.NewAddr == false {
+		eventType = EventAddressDeleted
+	}
+
+	// Get gateway for the interface
+	gatewayIP := nm.getGatewayForInterface(interfaceName)
+
+	// Create and send event
+	event := NetworkEvent{
+		Type:          eventType,
+		InterfaceName: interfaceName,
+		InterfaceInfo: interfaceInfo,
+		GatewayIP:     gatewayIP,
+		Timestamp:     time.Now(),
+	}
+
+	nm.sendEvent(event)
+
+	logger.WithFields(logrus.Fields{
+		"address":   update.LinkAddress.IP.String(),
+		"interface": interfaceName,
+		"action":    map[bool]string{true: "added", false: "deleted"}[update.NewAddr],
+	}).Debug("Address change on interface")
+}
+
+// shouldMonitorInterface checks if an interface should be monitored
+func (nm *networkMonitor) shouldMonitorInterface(name string) bool {
+	// Check ignore list
+	for _, ignored := range nm.config.IgnoreInterfaces {
+		if name == ignored {
+			return false
+		}
+	}
+
+	// Skip bridge interfaces as they are typically local LAN bridges, not upstream connections
+	if strings.HasPrefix(name, "br-") {
+		logger.WithField("interface", name).Debug("Skipping bridge interface - likely local LAN bridge")
+		return false
+	}
+
+	// Check only list
+	if len(nm.config.OnlyInterfaces) > 0 {
+		for _, allowed := range nm.config.OnlyInterfaces {
+			if name == allowed {
+				return true
+			}
+		}
+		return false
+	}
+
+	return true
+}
+
+// getGatewayForInterface gets the gateway IP for an interface
+func (nm *networkMonitor) getGatewayForInterface(interfaceName string) string {
+	link, err := netlink.LinkByName(interfaceName)
+	if err != nil {
+		logger.WithFields(logrus.Fields{
+			"interface": interfaceName,
+			"error":     err,
+		}).Debug("Error getting link for interface")
+		return ""
+	}
+
+	// Method 1: Check for default route on this specific interface
+	if gw := nm.getGatewayFromRoutes(link); gw != "" {
+		return gw
+	}
+
+	// Method 2: Check global routing table for default routes that use this interface
+	if gw := nm.getGatewayFromGlobalRoutes(link); gw != "" {
+		return gw
+	}
+
+	// Method 3: Infer gateway from IP address
+	if gw := nm.getGatewayByInference(link); gw != "" {
+		return gw
+	}
+
+	logger.WithField("interface", interfaceName).Debug("No gateway found for interface")
+	return ""
+}
+
+// getGatewayFromRoutes checks for a default route on a specific interface.
+func (nm *networkMonitor) getGatewayFromRoutes(link netlink.Link) string {
+	routes, err := netlink.RouteList(link, netlink.FAMILY_ALL)
+	if err != nil {
+		logger.WithFields(logrus.Fields{
+			"interface": link.Attrs().Name,
+			"error":     err,
+		}).Debug("Error getting routes for interface")
+		return ""
+	}
+
+	for _, route := range routes {
+		if route.Dst == nil && route.Gw != nil {
+			logger.WithFields(logrus.Fields{
+				"gateway":   route.Gw.String(),
+				"interface": link.Attrs().Name,
+			}).Debug("Found default route gateway for interface")
+			return route.Gw.String()
+		}
+	}
+	return ""
+}
+
+// getGatewayFromGlobalRoutes checks the global routing table for default routes that use this interface.
+func (nm *networkMonitor) getGatewayFromGlobalRoutes(link netlink.Link) string {
+	allRoutes, err := netlink.RouteList(nil, netlink.FAMILY_ALL)
+	if err != nil {
+		logger.WithError(err).Debug("Error getting global routes")
+		return ""
+	}
+
+	for _, route := range allRoutes {
+		if route.Dst == nil && route.Gw != nil && route.LinkIndex == link.Attrs().Index {
+			logger.WithFields(logrus.Fields{
+				"gateway":   route.Gw.String(),
+				"interface": link.Attrs().Name,
+			}).Debug("Found global default route gateway for interface")
+			return route.Gw.String()
+		}
+	}
+	return ""
+}
+
+// getGatewayByInference infers the gateway from the IP address of the interface.
+func (nm *networkMonitor) getGatewayByInference(link netlink.Link) string {
+	addrs, err := netlink.AddrList(link, netlink.FAMILY_V4)
+	if err != nil {
+		logger.WithFields(logrus.Fields{
+			"interface": link.Attrs().Name,
+			"error":     err,
+		}).Debug("Error getting addresses for interface")
+		return ""
+	}
+
+	for _, addr := range addrs {
+		ip := addr.IP
+		if ip.To4() != nil && !ip.IsLoopback() {
+			gatewayIP := nm.inferGatewayFromIP(ip, addr.Mask)
+			if gatewayIP != "" {
+				logger.WithFields(logrus.Fields{
+					"gateway":   gatewayIP,
+					"interface": link.Attrs().Name,
+					"ip":        ip.String(),
+				}).Debug("Inferred gateway for interface from IP")
+				return gatewayIP
+			}
+		}
+	}
+	return ""
+}
+
+// inferGatewayFromIP tries to infer the gateway IP from the interface IP and netmask
+func (nm *networkMonitor) inferGatewayFromIP(ip net.IP, mask net.IPMask) string {
+	if ip.To4() == nil {
+		return "" // Only handle IPv4
+	}
+
+	// Calculate network address
+	network := ip.Mask(mask)
+
+	// Common gateway patterns to try:
+	// 1. Network address + 1 (e.g., 192.168.1.1 for 192.168.1.0/24)
+	// 2. Network address + 254 (e.g., 192.168.1.254 for 192.168.1.0/24)
+
+	gatewayOptions := []net.IP{
+		net.IP{network[0], network[1], network[2], network[3] + 1},
+		net.IP{network[0], network[1], network[2], network[3] + 254},
+	}
+
+	for _, gateway := range gatewayOptions {
+		// Make sure gateway is in the same network
+		if gateway.Mask(mask).Equal(network) && !gateway.Equal(ip) {
+			// We could ping test here, but for now just return the first reasonable option
+			return gateway.String()
+		}
+	}
+
+	return ""
+}
+
+// GetCurrentInterfaces returns current network interface information
+func (nm *networkMonitor) GetCurrentInterfaces() ([]*InterfaceInfo, error) {
+	var interfaces []*InterfaceInfo
+
+	// Get all network links
+	links, err := netlink.LinkList()
+	if err != nil {
+		return nil, fmt.Errorf("failed to list network links: %w", err)
+	}
+
+	for _, link := range links {
+		attrs := link.Attrs()
+		if attrs == nil {
+			continue
+		}
+
+		// Check if we should monitor this interface
+		if !nm.shouldMonitorInterface(attrs.Name) {
+			continue
+		}
+
+		// Create interface info
+		interfaceInfo := &InterfaceInfo{
+			Name:           attrs.Name,
+			MacAddress:     attrs.HardwareAddr.String(),
+			IsUp:           attrs.Flags&net.FlagUp != 0,
+			IsLoopback:     attrs.Flags&net.FlagLoopback != 0,
+			IsPointToPoint: attrs.Flags&net.FlagPointToPoint != 0,
+		}
+
+		// Get IP addresses for the interface
+		addrs, err := netlink.AddrList(link, netlink.FAMILY_ALL)
+		if err == nil {
+			for _, addr := range addrs {
+				interfaceInfo.IPAddresses = append(interfaceInfo.IPAddresses, addr.IP.String())
+			}
+		}
+
+		interfaces = append(interfaces, interfaceInfo)
+	}
+
+	return interfaces, nil
+}
+
+// GetGatewayForInterface gets the gateway IP for an interface (public interface method)
+func (nm *networkMonitor) GetGatewayForInterface(interfaceName string) string {
+	return nm.getGatewayForInterface(interfaceName)
+}
+
+// sendEvent safely sends an event to the events channel with deduplication
+func (nm *networkMonitor) sendEvent(event NetworkEvent) {
+	// Create a unique key for this event type and interface
+	eventKey := fmt.Sprintf("%s:%d", event.InterfaceName, event.Type)
+
+	// Check if we should throttle this event
+	nm.eventMutex.Lock()
+	lastTime, exists := nm.lastEventTime[eventKey]
+	now := time.Now()
+
+	// Only send if enough time has passed since last event of this type
+	minInterval := 2 * time.Second // Configurable throttling interval
+	if exists && now.Sub(lastTime) < minInterval {
+		nm.eventMutex.Unlock()
+		// Skip this event - too soon since last one
+		return
+	}
+
+	// Update last event time
+	nm.lastEventTime[eventKey] = now
+	nm.eventMutex.Unlock()
+
+	select {
+	case nm.events <- event:
+		// Event sent successfully
+	default:
+		logger.WithField("interface", event.InterfaceName).Warn("Network event channel full, dropping event for interface")
+	}
+}
diff --git a/src/crowsnest/network_monitor_stub.go b/src/crowsnest/network_monitor_stub.go
new file mode 100644
index 0000000..881850f
--- /dev/null
+++ b/src/crowsnest/network_monitor_stub.go
@@ -0,0 +1,94 @@
+//go:build !linux
+// +build !linux
+
+package crowsnest
+
+import (
+	"fmt"
+	"time"
+
+	"github.com/OpenTollGate/tollgate-module-basic-go/src/config_manager"
+)
+
+// stubNetworkMonitor is a stub implementation for non-Linux systems
+type stubNetworkMonitor struct {
+	config   *config_manager.CrowsnestConfig
+	events   chan NetworkEvent
+	stopChan chan struct{}
+	running  bool
+}
+
+// NewNetworkMonitor creates a stub network monitor for non-Linux systems
+func NewNetworkMonitor(config *config_manager.CrowsnestConfig) NetworkMonitor {
+	logger.Warn("Using stub network monitor - netlink functionality only available on Linux")
+	return &stubNetworkMonitor{
+		config:   config,
+		events:   make(chan NetworkEvent, 100),
+		stopChan: make(chan struct{}),
+	}
+}
+
+// Start begins the stub monitor (does nothing on non-Linux)
+func (nm *stubNetworkMonitor) Start() error {
+	if nm.running {
+		return fmt.Errorf("stub network monitor is already running")
+	}
+
+	logger.Info("Starting stub network monitor (no actual monitoring on non-Linux systems)")
+	nm.running = true
+
+	// Send a fake interface up event for testing purposes
+	go func() {
+		time.Sleep(2 * time.Second)
+		testEvent := NetworkEvent{
+			Type:          EventInterfaceUp,
+			InterfaceName: "eth0",
+			InterfaceInfo: &InterfaceInfo{
+				Name:        "eth0",
+				MacAddress:  "00:11:22:33:44:55",
+				IPAddresses: []string{"192.168.1.100"},
+				IsUp:        true,
+			},
+			GatewayIP: "192.168.1.1",
+			Timestamp: time.Now(),
+		}
+
+		select {
+		case nm.events <- testEvent:
+			logger.Debug("Sent test network event for testing")
+		case <-nm.stopChan:
+			return
+		}
+	}()
+
+	return nil
+}
+
+// Stop stops the stub monitor
+func (nm *stubNetworkMonitor) Stop() error {
+	if !nm.running {
+		return nil
+	}
+
+	logger.Info("Stopping stub network monitor")
+	close(nm.stopChan)
+	nm.running = false
+	close(nm.events)
+
+	return nil
+}
+
+// Events returns the events channel
+func (nm *stubNetworkMonitor) Events() <-chan NetworkEvent {
+	return nm.events
+}
+
+// GetCurrentInterfaces returns empty interface list for stub
+func (nm *stubNetworkMonitor) GetCurrentInterfaces() ([]*InterfaceInfo, error) {
+	return []*InterfaceInfo{}, nil
+}
+
+// GetGatewayForInterface returns empty gateway for stub
+func (nm *stubNetworkMonitor) GetGatewayForInterface(interfaceName string) string {
+	return ""
+}
diff --git a/src/crowsnest/tollgate_prober.go b/src/crowsnest/tollgate_prober.go
new file mode 100644
index 0000000..b5bb373
--- /dev/null
+++ b/src/crowsnest/tollgate_prober.go
@@ -0,0 +1,257 @@
+package crowsnest
+
+import (
+	"context"
+	"fmt"
+	"io"
+	"net/http"
+	"sync"
+	"time"
+
+	"github.com/OpenTollGate/tollgate-module-basic-go/src/config_manager"
+	"github.com/sirupsen/logrus"
+)
+
+// tollGateProber implements the TollGateProber interface
+type tollGateProber struct {
+	config *config_manager.CrowsnestConfig
+	client *http.Client
+
+	// Track active probes for cancellation
+	activeProbes map[string]context.CancelFunc // key: interfaceName, value: cancel function
+	probesMutex  sync.RWMutex
+}
+
+// NewTollGateProber creates a new TollGate prober
+func NewTollGateProber(config *config_manager.CrowsnestConfig) TollGateProber {
+	// Create HTTP client with timeout
+	client := &http.Client{
+		Timeout: config.ProbeTimeout,
+		// Don't follow redirects for security
+		CheckRedirect: func(req *http.Request, via []*http.Request) error {
+			return http.ErrUseLastResponse
+		},
+	}
+
+	return &tollGateProber{
+		config:       config,
+		client:       client,
+		activeProbes: make(map[string]context.CancelFunc),
+	}
+}
+
+// ProbeGatewayWithContext probes a gateway with context for cancellation
+func (tp *tollGateProber) ProbeGatewayWithContext(ctx context.Context, interfaceName, gatewayIP string) ([]byte, error) {
+	if gatewayIP == "" {
+		return nil, fmt.Errorf("gateway IP is empty")
+	}
+
+	// Store the cancel function for this interface
+	tp.probesMutex.Lock()
+	tp.activeProbes[interfaceName] = func() {
+		// This function will be called when the probe is cancelled
+		// The actual cancellation is handled by the context
+	}
+	tp.probesMutex.Unlock()
+
+	// Cleanup when done
+	defer func() {
+		tp.probesMutex.Lock()
+		delete(tp.activeProbes, interfaceName)
+		tp.probesMutex.Unlock()
+	}()
+
+	url := fmt.Sprintf("http://%s:2121/", gatewayIP)
+	logger.WithField("gateway", gatewayIP).Info("Probing gateway for TollGate advertisement (with context)")
+
+	var lastErr error
+
+	// Retry logic with context
+	for attempt := 0; attempt < tp.config.ProbeRetryCount; attempt++ {
+		// Check if context is cancelled
+		select {
+		case <-ctx.Done():
+			return nil, fmt.Errorf("probe cancelled: %w", ctx.Err())
+		default:
+		}
+
+		if attempt > 0 {
+			logger.WithFields(logrus.Fields{
+				"gateway": gatewayIP,
+				"attempt": attempt,
+			}).Debug("Retry attempt for gateway")
+
+			// Wait with context awareness
+			select {
+			case <-ctx.Done():
+				return nil, fmt.Errorf("probe cancelled during retry delay: %w", ctx.Err())
+			case <-time.After(tp.config.ProbeRetryDelay):
+			}
+		}
+
+		data, err := tp.performRequestWithContext(ctx, url)
+		if err == nil {
+			logger.WithField("gateway", gatewayIP).Info("Successfully received response from gateway")
+
+			// TEMPORARY WORKAROUND: Trigger captive portal session after successful probe
+			// This ensures ndsctl creates a client session for our device
+			go func() {
+				err := tp.TriggerCaptivePortalSession(ctx, gatewayIP)
+				if err != nil {
+					logger.WithFields(logrus.Fields{
+						"gateway": gatewayIP,
+						"error":   err,
+					}).Debug("Captive portal trigger failed (non-critical)")
+				}
+			}()
+
+			return data, nil
+		}
+
+		lastErr = err
+		logger.WithFields(logrus.Fields{
+			"gateway": gatewayIP,
+			"attempt": attempt + 1,
+			"error":   err,
+		}).Warn("Probe attempt failed for gateway")
+	}
+
+	return nil, fmt.Errorf("failed to probe gateway %s after %d attempts: %w",
+		gatewayIP, tp.config.ProbeRetryCount, lastErr)
+}
+
+// CancelProbesForInterface cancels any active probes for the specified interface
+func (tp *tollGateProber) CancelProbesForInterface(interfaceName string) {
+	tp.probesMutex.Lock()
+	defer tp.probesMutex.Unlock()
+
+	if cancelFunc, exists := tp.activeProbes[interfaceName]; exists {
+		logger.WithField("interface", interfaceName).Info("Cancelling active probe for interface")
+		cancelFunc()
+		delete(tp.activeProbes, interfaceName)
+	}
+}
+
+// performRequestWithContext performs a single HTTP request with context
+func (tp *tollGateProber) performRequestWithContext(ctx context.Context, url string) ([]byte, error) {
+	// Create request with context
+	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
+	if err != nil {
+		return nil, fmt.Errorf("failed to create request: %w", err)
+	}
+
+	// Set appropriate headers
+	req.Header.Set("User-Agent", "TollGate-Crowsnest/1.0")
+	req.Header.Set("Accept", "application/json")
+
+	// Perform request
+	resp, err := tp.client.Do(req)
+	if err != nil {
+		return nil, fmt.Errorf("HTTP request failed: %w", err)
+	}
+	defer resp.Body.Close()
+
+	// Check status code
+	if resp.StatusCode != http.StatusOK {
+		return nil, fmt.Errorf("HTTP request returned status %d: %s", resp.StatusCode, resp.Status)
+	}
+
+	// Check content type (optional, but good practice)
+	contentType := resp.Header.Get("Content-Type")
+	if contentType != "" && contentType != "application/json" {
+		logger.WithFields(logrus.Fields{
+			"url":          url,
+			"content_type": contentType,
+		}).Warn("Gateway returned unexpected content type")
+	}
+
+	// Read response body
+	body, err := io.ReadAll(resp.Body)
+	if err != nil {
+		return nil, fmt.Errorf("failed to read response body: %w", err)
+	}
+
+	// Check if response is empty
+	if len(body) == 0 {
+		return nil, fmt.Errorf("received empty response from gateway")
+	}
+
+	// Basic size validation
+	if len(body) > 1024*1024 { // 1MB limit
+		return nil, fmt.Errorf("response too large: %d bytes", len(body))
+	}
+
+	return body, nil
+}
+
+// TriggerCaptivePortalSession makes an HTTP GET request to port 80 to trigger ndsctl session creation
+//
+// TEMPORARY WORKAROUND: This is a temporary measure to ensure the upstream TollGate's ndsctl
+// creates a client session for our device. This is NOT a long-term solution as it goes against
+// the TollGate protocol specification.
+//
+// Background: After successful payment (port 2121), the upstream TollGate should automatically
+// create the session. However, some implementations require a captive portal request (port 80)
+// to trigger the ndsctl session creation.
+//
+// TODO: Remove this workaround once upstream TollGate implementations properly handle
+// automatic session creation after payment validation.
+func (tp *tollGateProber) TriggerCaptivePortalSession(ctx context.Context, gatewayIP string) error {
+	if gatewayIP == "" {
+		return fmt.Errorf("gateway IP is empty")
+	}
+
+	// Make HTTP GET request to port 80 (standard captive portal)
+	url := fmt.Sprintf("http://%s:80/", gatewayIP)
+
+	logger.WithFields(logrus.Fields{
+		"gateway_ip":    gatewayIP,
+		"url":           url,
+		"purpose":       "trigger_ndsctl_session",
+		"protocol_note": "TEMPORARY WORKAROUND - not part of TollGate protocol",
+	}).Info("🚨 TEMPORARY: Triggering captive portal session for ndsctl")
+
+	// Create request with context and short timeout
+	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
+	if err != nil {
+		return fmt.Errorf("failed to create captive portal request: %w", err)
+	}
+
+	// Set headers that mimic a typical browser request
+	req.Header.Set("User-Agent", "Mozilla/5.0 (compatible; TollGate-Client/1.0)")
+	req.Header.Set("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
+	req.Header.Set("Accept-Language", "en-US,en;q=0.5")
+	req.Header.Set("Connection", "close")
+
+	// Use a separate client with shorter timeout for captive portal
+	captiveClient := &http.Client{
+		Timeout: 10 * time.Second, // Short timeout for captive portal
+		CheckRedirect: func(req *http.Request, via []*http.Request) error {
+			// Allow redirects for captive portal (common behavior)
+			return nil
+		},
+	}
+
+	// Perform the request
+	resp, err := captiveClient.Do(req)
+	if err != nil {
+		logger.WithFields(logrus.Fields{
+			"gateway_ip": gatewayIP,
+			"error":      err,
+		}).Warn("Captive portal request failed (this is expected and non-critical)")
+		// Don't return error - this is a best-effort attempt
+		return nil
+	}
+	defer resp.Body.Close()
+
+	// Read and discard response body (we don't need the content)
+	_, _ = io.ReadAll(resp.Body)
+
+	logger.WithFields(logrus.Fields{
+		"gateway_ip":   gatewayIP,
+		"status_code":  resp.StatusCode,
+		"content_type": resp.Header.Get("Content-Type"),
+	}).Info("✅ Captive portal request completed - ndsctl session should be triggered")
+
+	return nil
+}
diff --git a/src/crowsnest/types.go b/src/crowsnest/types.go
new file mode 100644
index 0000000..118a81c
--- /dev/null
+++ b/src/crowsnest/types.go
@@ -0,0 +1,54 @@
+package crowsnest
+
+import (
+	"time"
+)
+
+// NetworkEvent represents a network state change event
+type NetworkEvent struct {
+	Type          EventType
+	InterfaceName string
+	InterfaceInfo *InterfaceInfo
+	GatewayIP     string
+	Timestamp     time.Time
+}
+
+// EventType represents the type of network event
+type EventType int
+
+const (
+	EventInterfaceUp EventType = iota
+	EventInterfaceDown
+	EventRouteDeleted
+	EventAddressAdded
+	EventAddressDeleted
+)
+
+// InterfaceInfo contains information about a network interface
+type InterfaceInfo struct {
+	Name           string
+	MacAddress     string
+	IPAddresses    []string
+	IsUp           bool
+	IsLoopback     bool
+	IsPointToPoint bool
+}
+
+// DiscoveryAttempt tracks discovery attempts to prevent duplicates
+type DiscoveryAttempt struct {
+	InterfaceName string
+	GatewayIP     string
+	AttemptTime   time.Time
+	Result        DiscoveryResult
+}
+
+// DiscoveryResult represents the result of a discovery attempt
+type DiscoveryResult int
+
+const (
+	DiscoveryResultPending DiscoveryResult = iota
+	DiscoveryResultSuccess
+	DiscoveryResultNotTollGate
+	DiscoveryResultValidationFailed
+	DiscoveryResultError
+)
diff --git a/src/go.mod b/src/go.mod
index 196ebeb..c951fe3 100644
--- a/src/go.mod
+++ b/src/go.mod
@@ -3,21 +3,26 @@ module github.com/OpenTollGate/tollgate-module-basic-go
 go 1.24.2
 
 require (
+	github.com/OpenTollGate/tollgate-module-basic-go/src/chandler v0.0.0-00010101000000-000000000000
 	github.com/OpenTollGate/tollgate-module-basic-go/src/config_manager v0.0.0
+	github.com/OpenTollGate/tollgate-module-basic-go/src/crowsnest v0.0.0-00010101000000-000000000000
 	github.com/OpenTollGate/tollgate-module-basic-go/src/janitor v0.0.0-00010101000000-000000000000
-	github.com/OpenTollGate/tollgate-module-basic-go/src/merchant v0.0.0-20250526110008-c13aa6acd08e
+	github.com/OpenTollGate/tollgate-module-basic-go/src/merchant v0.0.0
 	github.com/OpenTollGate/tollgate-module-basic-go/src/relay v0.0.0-00010101000000-000000000000
 	github.com/btcsuite/btcd/btcutil v1.1.6
 	github.com/nbd-wtf/go-nostr v0.51.12
-	github.com/stretchr/testify v1.10.0
+	github.com/sirupsen/logrus v1.9.3
 )
 
 replace (
+	github.com/OpenTollGate/tollgate-module-basic-go/src/chandler => ./chandler
 	github.com/OpenTollGate/tollgate-module-basic-go/src/config_manager => ./config_manager
+	github.com/OpenTollGate/tollgate-module-basic-go/src/crowsnest => ./crowsnest
 	github.com/OpenTollGate/tollgate-module-basic-go/src/janitor => ./janitor
 	github.com/OpenTollGate/tollgate-module-basic-go/src/lightning => ./lightning
 	github.com/OpenTollGate/tollgate-module-basic-go/src/merchant => ./merchant
 	github.com/OpenTollGate/tollgate-module-basic-go/src/relay => ./relay
+	github.com/OpenTollGate/tollgate-module-basic-go/src/tollgate_protocol => ./tollgate_protocol
 	github.com/OpenTollGate/tollgate-module-basic-go/src/tollwallet => ./tollwallet
 	github.com/OpenTollGate/tollgate-module-basic-go/src/utils => ./utils
 	github.com/OpenTollGate/tollgate-module-basic-go/src/valve => ./valve
@@ -26,9 +31,11 @@ replace (
 require (
 	github.com/ImVexed/fasturl v0.0.0-20230304231329-4e41488060f3 // indirect
 	github.com/OpenTollGate/tollgate-module-basic-go/src/lightning v0.0.0-00010101000000-000000000000 // indirect
+	github.com/OpenTollGate/tollgate-module-basic-go/src/tollgate_protocol v0.0.0 // indirect
 	github.com/OpenTollGate/tollgate-module-basic-go/src/tollwallet v0.0.0 // indirect
 	github.com/OpenTollGate/tollgate-module-basic-go/src/utils v0.0.0 // indirect
 	github.com/OpenTollGate/tollgate-module-basic-go/src/valve v0.0.0 // indirect
+	github.com/Origami74/gonuts-tollgate v0.6.1 // indirect
 	github.com/aead/chacha20 v0.0.0-20180709150244-8b13a72661da // indirect
 	github.com/aead/siphash v1.0.1 // indirect
 	github.com/andybalholm/brotli v1.1.1 // indirect
@@ -58,7 +65,6 @@ require (
 	github.com/decred/dcrd/crypto/blake256 v1.1.0 // indirect
 	github.com/decred/dcrd/dcrec/secp256k1/v4 v4.4.0 // indirect
 	github.com/decred/dcrd/lru v1.1.3 // indirect
-	github.com/elnosh/gonuts v0.4.0 // indirect
 	github.com/fasthttp/websocket v1.5.12 // indirect
 	github.com/fiatjaf/eventstore v0.16.2 // indirect
 	github.com/fiatjaf/khatru v0.18.1 // indirect
@@ -98,6 +104,7 @@ require (
 	github.com/rs/cors v1.11.1 // indirect
 	github.com/savsgio/gotils v0.0.0-20240704082632-aef3928b8a38 // indirect
 	github.com/stretchr/objx v0.5.2 // indirect
+	github.com/stretchr/testify v1.10.0 // indirect
 	github.com/syndtr/goleveldb v1.0.1-0.20210819022825-2ae1ddf74ef7 // indirect
 	github.com/tidwall/gjson v1.18.0 // indirect
 	github.com/tidwall/match v1.1.1 // indirect
@@ -106,6 +113,8 @@ require (
 	github.com/tyler-smith/go-bip39 v1.1.0 // indirect
 	github.com/valyala/bytebufferpool v1.0.0 // indirect
 	github.com/valyala/fasthttp v1.59.0 // indirect
+	github.com/vishvananda/netlink v1.3.1 // indirect
+	github.com/vishvananda/netns v0.0.5 // indirect
 	github.com/x448/float16 v0.8.4 // indirect
 	go.etcd.io/bbolt v1.4.0 // indirect
 	go.etcd.io/etcd/client/v2 v2.305.16 // indirect
diff --git a/src/go.sum b/src/go.sum
index a49175c..203b95c 100644
--- a/src/go.sum
+++ b/src/go.sum
@@ -10,6 +10,8 @@ github.com/Microsoft/go-winio v0.6.2 h1:F2VQgta7ecxGYO8k3ZZz3RS8fVIXVxONVUPlNERo
 github.com/Microsoft/go-winio v0.6.2/go.mod h1:yd8OoFMLzJbo9gZq8j5qaps8bJ9aShtEA8Ipt1oGCvU=
 github.com/Nvveen/Gotty v0.0.0-20120604004816-cd527374f1e5 h1:TngWCqHvy9oXAN6lEVMRuU21PR1EtLVZJmdB18Gu3Rw=
 github.com/Nvveen/Gotty v0.0.0-20120604004816-cd527374f1e5/go.mod h1:lmUJ/7eu/Q8D7ML55dXQrVaamCz2vxCfdQBasLZfHKk=
+github.com/Origami74/gonuts-tollgate v0.6.1 h1:BJM5XOyyH3YmaPBIvTmpiklmCv0XBWDA9tsSpD6818s=
+github.com/Origami74/gonuts-tollgate v0.6.1/go.mod h1:poaPkWGzuubGX1PQKIBwfXG3LYNxkMLza5s4239NaNs=
 github.com/aead/chacha20 v0.0.0-20180709150244-8b13a72661da h1:KjTM2ks9d14ZYCvmHS9iAKVt9AyzRSqNU1qabPih5BY=
 github.com/aead/chacha20 v0.0.0-20180709150244-8b13a72661da/go.mod h1:eHEWzANqSiWQsof+nXEI9bUVUyV6F53Fp89EuCh2EAA=
 github.com/aead/siphash v1.0.1 h1:FwHfE/T45KPKYuuSAKyyvE+oPWcaQ+CUmFW0bPlM+kg=
@@ -122,10 +124,8 @@ github.com/docker/go-units v0.5.0/go.mod h1:fgPhTUdO+D/Jk86RDLlptpiXQzgHJF7gydDD
 github.com/dustin/go-humanize v1.0.1 h1:GzkhY7T5VNhEkwH0PVJgjz+fX1rhBrR7pRT3mDkpeCY=
 github.com/dustin/go-humanize v1.0.1/go.mod h1:Mu1zIs6XwVuF/gI1OepvI0qD18qycQx+mFykh5fBlto=
 github.com/dvyukov/go-fuzz v0.0.0-20200318091601-be3528f3a813/go.mod h1:11Gm+ccJnvAhCNLlf5+cS9KjtbaD5I5zaZpFMsTHWTw=
-github.com/elnosh/btc-docker-test v0.0.0-20241223164556-146e52a0433b h1:JbZVAqKBVRkvHuZZJsf8MvO+I7HGaVNCMQvp7WMFGqs=
-github.com/elnosh/btc-docker-test v0.0.0-20241223164556-146e52a0433b/go.mod h1:4PlP53czOHN+XvjyQZh+zgrzkI7BYFvJajxKK2zquyE=
-github.com/elnosh/gonuts v0.4.0 h1:7d80ngsxdA2FrpNh4/9J7p0NSU9iWFK+Wh2nAxR1qM0=
-github.com/elnosh/gonuts v0.4.0/go.mod h1:vgZomh4YQk7R3w4ltZc0sHwCmndfHkuX6V4sga/8oNs=
+github.com/elnosh/btc-docker-test v0.1.0 h1:5Ilyd7HvGYZEO9Cy4t44SB27P9arXtPikxMri4pdxAo=
+github.com/elnosh/btc-docker-test v0.1.0/go.mod h1:4PlP53czOHN+XvjyQZh+zgrzkI7BYFvJajxKK2zquyE=
 github.com/fasthttp/websocket v1.5.12 h1:e4RGPpWW2HTbL3zV0Y/t7g0ub294LkiuXXUuTOUInlE=
 github.com/fasthttp/websocket v1.5.12/go.mod h1:I+liyL7/4moHojiOgUOIKEWm9EIxHqxZChS+aMFltyg=
 github.com/felixge/httpsnoop v1.0.4 h1:NFTV2Zj1bL4mc9sqWACXbQFVBBg2W3GPvqp8/ESS2Wg=
@@ -154,8 +154,8 @@ github.com/go-viper/mapstructure/v2 v2.2.1 h1:ZAaOCxANMuZx5RCeg0mBdEZk7DZasvvZIx
 github.com/go-viper/mapstructure/v2 v2.2.1/go.mod h1:oJDH3BJKyqBA2TXFhDsKDGDTlndYOZ6rGS0BRZIxGhM=
 github.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=
 github.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69NZV8Q=
-github.com/golang-jwt/jwt/v4 v4.5.1 h1:JdqV9zKUdtaa9gdPlywC3aeoEsR681PlKC+4F5gQgeo=
-github.com/golang-jwt/jwt/v4 v4.5.1/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w39/MY0Ch0=
+github.com/golang-jwt/jwt/v4 v4.5.2 h1:YtQM7lnr8iZ+j5q71MGKkNw9Mn7AjHM68uc9g5fXeUI=
+github.com/golang-jwt/jwt/v4 v4.5.2/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w39/MY0Ch0=
 github.com/golang-migrate/migrate/v4 v4.18.1 h1:JML/k+t4tpHCpQTCAD62Nu43NUFzHY4CV3uAuvHGC+Y=
 github.com/golang-migrate/migrate/v4 v4.18.1/go.mod h1:HAX6m3sQgcdO81tdjn5exv20+3Kb13cmGli1hrD6hks=
 github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
@@ -426,6 +426,10 @@ github.com/valyala/bytebufferpool v1.0.0 h1:GqA5TC/0021Y/b9FG4Oi9Mr3q7XYx6Kllzaw
 github.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=
 github.com/valyala/fasthttp v1.59.0 h1:Qu0qYHfXvPk1mSLNqcFtEk6DpxgA26hy6bmydotDpRI=
 github.com/valyala/fasthttp v1.59.0/go.mod h1:GTxNb9Bc6r2a9D0TWNSPwDz78UxnTGBViY3xZNEqyYU=
+github.com/vishvananda/netlink v1.3.1 h1:3AEMt62VKqz90r0tmNhog0r/PpWKmrEShJU0wJW6bV0=
+github.com/vishvananda/netlink v1.3.1/go.mod h1:ARtKouGSTGchR8aMwmkzC0qiNPrrWO5JS/XMVl45+b4=
+github.com/vishvananda/netns v0.0.5 h1:DfiHV+j8bA32MFM7bfEunvT8IAqQ/NzSJHtcmW5zdEY=
+github.com/vishvananda/netns v0.0.5/go.mod h1:SpkAiCQRtJ6TvvxPnOSyH3BMl6unz3xZlaprSwhNNJM=
 github.com/x448/float16 v0.8.4 h1:qLwI1I70+NjRFUR3zs1JPUCgaCXSh3SW62uAKT1mSBM=
 github.com/x448/float16 v0.8.4/go.mod h1:14CWIYCyZA/cWjXOioeEpHeN/83MdbZDRQHoFcYsOfg=
 github.com/xeipuuv/gojsonpointer v0.0.0-20190905194746-02993c407bfb h1:zGWFAtiMcyryUHoUjUJX0/lt1H2+i2Ka2n+D3DImSNo=
@@ -512,6 +516,9 @@ golang.org/x/sys v0.0.0-20191120155948-bd437916bb0e/go.mod h1:h1NjWce9XRLGQEsW7w
 golang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20200519105757-fe76b779f299/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20200814200057-3d37ad5750ed/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
+golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+golang.org/x/sys v0.2.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+golang.org/x/sys v0.10.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.33.0 h1:q3i8TbbEz+JRD9ywIRlyRAQbM0qF7hu24q3teo2hbuw=
 golang.org/x/sys v0.33.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
 golang.org/x/term v0.32.0 h1:DR4lr0TjUs3epypdhTOkMmuF5CDFJ/8pOnbzMZPQ7bg=
diff --git a/src/main.go b/src/main.go
index 71aa1d2..deeabf0 100644
--- a/src/main.go
+++ b/src/main.go
@@ -12,11 +12,14 @@ import (
 	"strings"
 	"time"
 
+	"github.com/OpenTollGate/tollgate-module-basic-go/src/chandler"
 	"github.com/OpenTollGate/tollgate-module-basic-go/src/config_manager"
+	"github.com/OpenTollGate/tollgate-module-basic-go/src/crowsnest"
 	"github.com/OpenTollGate/tollgate-module-basic-go/src/janitor"
 	"github.com/OpenTollGate/tollgate-module-basic-go/src/merchant"
 	"github.com/OpenTollGate/tollgate-module-basic-go/src/relay"
 	"github.com/nbd-wtf/go-nostr"
+	"github.com/sirupsen/logrus"
 )
 
 // Global configuration variable
@@ -27,7 +30,7 @@ var (
 	installConfig *config_manager.InstallConfig
 )
 var tollgateDetailsString string
-var merchantInstance *merchant.Merchant
+var merchantInstance merchant.MerchantInterface
 
 // getTollgatePaths returns the configuration file paths based on the environment.
 // If TOLLGATE_TEST_CONFIG_DIR is set, it uses paths within that directory for testing.
@@ -46,6 +49,25 @@ func getTollgatePaths() (configPath, installPath, identitiesPath string) {
 	return
 }
 
+func InitializeGlobalLogger(logLevel string) {
+	level, err := logrus.ParseLevel(strings.ToLower(logLevel))
+	if err != nil {
+		// Default to info level if parsing fails
+		level = logrus.InfoLevel
+		logrus.WithError(err).Warn("Failed to parse log level, defaulting to info")
+	}
+
+	logrus.SetLevel(level)
+
+	// Set a consistent formatter for the entire application
+	logrus.SetFormatter(&logrus.TextFormatter{
+		FullTimestamp: true,
+		ForceColors:   true,
+	})
+
+	logrus.WithField("log_level", level.String()).Info("Global logger initialized")
+}
+
 func init() {
 	var err error
 
@@ -60,6 +82,9 @@ func init() {
 
 	mainConfig = configManager.GetConfig()
 
+	// Initialize global logger with the configured log level
+	InitializeGlobalLogger(mainConfig.LogLevel)
+
 	IPAddressRandomized := fmt.Sprintf("%t", installConfig.IPAddressRandomized)
 	log.Printf("IPAddressRandomized: %s", IPAddressRandomized)
 
@@ -76,10 +101,13 @@ func init() {
 	merchantInstance.StartPayoutRoutine()
 
 	// Initialize janitor module
-	initJanitor()
+	// initJanitor()
 
 	// Initialize private relay
 	initPrivateRelay()
+
+	// Initialize crowsnest module
+	initCrowsnest()
 }
 
 func initJanitor() {
@@ -97,6 +125,26 @@ func initPrivateRelay() {
 	log.Println("Private relay initialization started")
 }
 
+func initCrowsnest() {
+	crowsnestInstance, err := crowsnest.NewCrowsnest(configManager)
+	if err != nil {
+		log.Fatalf("Failed to create crowsnest instance: %v", err)
+	}
+
+	// Create and set chandler instance
+	chandlerInstance, err := chandler.NewChandler(configManager, merchantInstance)
+	crowsnestInstance.SetChandler(chandlerInstance)
+
+	go func() {
+		err := crowsnestInstance.Start()
+		if err != nil {
+			log.Printf("Error starting crowsnest: %v", err)
+		}
+	}()
+
+	log.Println("Crowsnest module initialized with chandler and monitoring network changes")
+}
+
 func startPrivateRelayWithAutoRestart() {
 	for {
 		log.Println("Starting TollGate private relay on ws://localhost:4242")
@@ -268,7 +316,7 @@ func HandleRootPost(w http.ResponseWriter, r *http.Request) {
 }
 
 // sendNoticeResponse creates and sends a notice event response
-func sendNoticeResponse(w http.ResponseWriter, merchantInstance *merchant.Merchant, statusCode int, level, code, message, customerPubkey string) {
+func sendNoticeResponse(w http.ResponseWriter, merchantInstance merchant.MerchantInterface, statusCode int, level, code, message, customerPubkey string) {
 	noticeEvent, err := merchantInstance.CreateNoticeEvent(level, code, message, customerPubkey)
 	if err != nil {
 		log.Printf("Error creating notice event: %v", err)
diff --git a/src/merchant/go.mod b/src/merchant/go.mod
index dab10d7..5dbffc6 100644
--- a/src/merchant/go.mod
+++ b/src/merchant/go.mod
@@ -7,7 +7,7 @@ require (
 	github.com/OpenTollGate/tollgate-module-basic-go/src/tollwallet v0.0.0
 	github.com/OpenTollGate/tollgate-module-basic-go/src/utils v0.0.0
 	github.com/OpenTollGate/tollgate-module-basic-go/src/valve v0.0.0
-	github.com/elnosh/gonuts v0.4.0
+	github.com/Origami74/gonuts-tollgate v0.6.1
 	github.com/nbd-wtf/go-nostr v0.51.11
 )
 
diff --git a/src/merchant/merchant.go b/src/merchant/merchant.go
index 1c0b5b2..6a9288e 100644
--- a/src/merchant/merchant.go
+++ b/src/merchant/merchant.go
@@ -4,30 +4,59 @@ import (
 	"encoding/json"
 	"fmt"
 	"log"
-	"os"
 	"math"
+	"os"
 	"path/filepath"
 	"strconv"
 	"strings"
 	"time"
 
+	"sync"
+
 	"github.com/OpenTollGate/tollgate-module-basic-go/src/config_manager"
 	"github.com/OpenTollGate/tollgate-module-basic-go/src/tollwallet"
 	"github.com/OpenTollGate/tollgate-module-basic-go/src/utils"
 	"github.com/OpenTollGate/tollgate-module-basic-go/src/valve"
-	"github.com/elnosh/gonuts/cashu"
+	"github.com/Origami74/gonuts-tollgate/cashu"
 	"github.com/nbd-wtf/go-nostr"
 )
 
+// CustomerSession represents an active session
+type CustomerSession struct {
+	MacAddress string
+	StartTime  int64  // Unix timestamp
+	Metric     string // "milliseconds" or "bytes"
+	Allotment  uint64 // Total allotment for this session
+}
+
+// MerchantInterface defines the interface for merchant payment operations
+type MerchantInterface interface {
+	CreatePaymentToken(mintURL string, amount uint64) (string, error)
+	CreatePaymentTokenWithOverpayment(mintURL string, amount uint64, maxOverpaymentPercent uint64, maxOverpaymentAbsolute uint64) (string, error)
+	GetAcceptedMints() []config_manager.MintConfig
+	GetBalance() uint64
+	GetBalanceByMint(mintURL string) uint64
+	PurchaseSession(paymentEvent nostr.Event) (*nostr.Event, error)
+	GetAdvertisement() string
+	StartPayoutRoutine()
+	CreateNoticeEvent(level, code, message, customerPubkey string) (*nostr.Event, error)
+	// New session management methods
+	GetSession(macAddress string) (*CustomerSession, error)
+	AddAllotment(macAddress, metric string, amount uint64) (*CustomerSession, error)
+}
+
 // Merchant represents the financial decision maker for the tollgate
 type Merchant struct {
 	config        *config_manager.Config
 	configManager *config_manager.ConfigManager
 	tollwallet    tollwallet.TollWallet
 	advertisement string
+	// In-memory session store
+	customerSessions map[string]*CustomerSession
+	sessionMu        sync.RWMutex
 }
 
-func New(configManager *config_manager.ConfigManager) (*Merchant, error) {
+func New(configManager *config_manager.ConfigManager) (MerchantInterface, error) {
 	log.Printf("=== Merchant Initializing ===")
 
 	config := configManager.GetConfig()
@@ -65,10 +94,11 @@ func New(configManager *config_manager.ConfigManager) (*Merchant, error) {
 	log.Printf("=== Merchant ready ===")
 
 	return &Merchant{
-		config:        config,
-		configManager: configManager,
-		tollwallet:    *tollwallet,
-		advertisement: advertisementStr,
+		config:           config,
+		configManager:    configManager,
+		tollwallet:       *tollwallet,
+		advertisement:    advertisementStr,
+		customerSessions: make(map[string]*CustomerSession),
 	}, nil
 }
 
@@ -225,42 +255,32 @@ func (m *Merchant) PurchaseSession(paymentEvent nostr.Event) (*nostr.Event, erro
 		return noticeEvent, nil
 	}
 
-	// Check for existing session
-	customerPubkey := paymentEvent.PubKey
-	existingSession, err := m.getLatestSession(customerPubkey)
+	// Use MAC-address based session management
+	macAddress := deviceIdentifier
+
+	// Add allotment to session (creates new session if doesn't exist)
+	metric := "milliseconds" // Use milliseconds as default metric
+	session, err := m.AddAllotment(macAddress, metric, allotment)
 	if err != nil {
-		log.Printf("Warning: failed to query existing session: %v", err)
+		noticeEvent, noticeErr := m.CreateNoticeEvent("error", "session-management-failed",
+			fmt.Sprintf("Failed to manage session: %v", err), paymentEvent.PubKey)
+		if noticeErr != nil {
+			return nil, fmt.Errorf("failed to manage session and failed to create notice: %w", noticeErr)
+		}
+		return noticeEvent, nil
 	}
 
-	var sessionEvent *nostr.Event
-	if existingSession != nil {
-		// Extend existing session
-		sessionEvent, err = m.extendSessionEvent(existingSession, allotment)
-		if err != nil {
-			noticeEvent, noticeErr := m.CreateNoticeEvent("error", "session-extension-failed",
-				fmt.Sprintf("Failed to extend session: %v", err), paymentEvent.PubKey)
-			if noticeErr != nil {
-				return nil, fmt.Errorf("failed to extend session and failed to create notice: %w", noticeErr)
-			}
-			return noticeEvent, nil
-		}
-		log.Printf("Extended session for customer %s", customerPubkey)
+	// Calculate end timestamp based on session allotment
+	var endTimestamp int64
+	if session.Metric == "milliseconds" {
+		endTimestamp = session.StartTime + int64(session.Allotment/1000)
 	} else {
-		// Create new session
-		sessionEvent, err = m.createSessionEvent(paymentEvent, allotment)
-		if err != nil {
-			noticeEvent, noticeErr := m.CreateNoticeEvent("error", "session-creation-failed",
-				fmt.Sprintf("Failed to create session: %v", err), paymentEvent.PubKey)
-			if noticeErr != nil {
-				return nil, fmt.Errorf("failed to create session and failed to create notice: %w", noticeErr)
-			}
-			return noticeEvent, nil
-		}
-		log.Printf("Created new session for customer %s", customerPubkey)
+		// For other metrics, set to 24h from now
+		endTimestamp = time.Now().Unix() + (24 * 60 * 60) // 24 hours from now
 	}
 
-	// Update valve with session information
-	err = valve.OpenGateForSession(*sessionEvent, m.config)
+	// Open gate until the calculated end time
+	err = valve.OpenGateUntil(macAddress, endTimestamp)
 	if err != nil {
 		noticeEvent, noticeErr := m.CreateNoticeEvent("error", "gate-opening-failed",
 			fmt.Sprintf("Failed to open gate for session: %v", err), paymentEvent.PubKey)
@@ -270,10 +290,10 @@ func (m *Merchant) PurchaseSession(paymentEvent nostr.Event) (*nostr.Event, erro
 		return noticeEvent, nil
 	}
 
-	// Publish session event to local pool only (for privacy)
-	err = m.publishLocal(sessionEvent)
+	// Create a success notice event
+	sessionEvent, err := m.createSessionEvent(session, paymentEvent.PubKey)
 	if err != nil {
-		log.Printf("Warning: failed to publish session event to local pool: %v", err)
+		return nil, fmt.Errorf("failed to create session event: %w", err)
 	}
 
 	return sessionEvent, nil
@@ -530,13 +550,9 @@ func (m *Merchant) isSessionActive(sessionEvent *nostr.Event) bool {
 	return isActive
 }
 
-// createSessionEvent creates a new session event
-func (m *Merchant) createSessionEvent(paymentEvent nostr.Event, allotment uint64) (*nostr.Event, error) {
-	customerPubkey := paymentEvent.PubKey
-	deviceIdentifier, err := m.extractDeviceIdentifier(paymentEvent)
-	if err != nil {
-		return nil, err
-	}
+// createSessionEvent creates a session event from the MAC-address based session
+func (m *Merchant) createSessionEvent(session *CustomerSession, customerPubkey string) (*nostr.Event, error) {
+	deviceIdentifier := session.MacAddress
 
 	identities := m.configManager.GetIdentities()
 	if identities == nil {
@@ -560,8 +576,9 @@ func (m *Merchant) createSessionEvent(paymentEvent nostr.Event, allotment uint64
 		Tags: nostr.Tags{
 			{"p", customerPubkey},
 			{"device-identifier", "mac", deviceIdentifier},
-			{"allotment", fmt.Sprintf("%d", allotment)},
-			{"metric", m.config.Metric},
+			{"allotment", fmt.Sprintf("%d", session.Allotment)},
+			{"metric", session.Metric},
+			{"start-time", fmt.Sprintf("%d", session.StartTime)},
 		},
 		Content: "",
 	}
@@ -607,7 +624,7 @@ func (m *Merchant) extendSessionEvent(existingSession *nostr.Event, additionalAl
 	}
 
 	// Calculate new total allotment
-	newTotalAllotment := leftoverAllotment + additionalAllotment
+	newTotalAllotment := existingAllotment + additionalAllotment
 
 	// Extract customer and device info from existing session
 	customerPubkey := ""
@@ -757,3 +774,109 @@ func (m *Merchant) CreateNoticeEvent(level, code, message, customerPubkey string
 
 	return noticeEvent, nil
 }
+
+// MerchantInterface method implementations
+
+// CreatePaymentToken creates a payment token for the specified mint and amount
+func (m *Merchant) CreatePaymentToken(mintURL string, amount uint64) (string, error) {
+	// Check balance before attempting to send
+	balance := m.tollwallet.GetBalanceByMint(mintURL)
+	totalBalance := m.tollwallet.GetBalance()
+
+	log.Printf("Creating payment token: amount=%d, mintURL=%s, balance_by_mint=%d, total_balance=%d",
+		amount, mintURL, balance, totalBalance)
+
+	if balance < amount {
+		return "", fmt.Errorf("insufficient balance: need %d sats, have %d sats for mint %s (total balance: %d)",
+			amount, balance, mintURL, totalBalance)
+	}
+
+	// Use the tollwallet to create a payment token with basic send
+	token, err := m.tollwallet.Send(amount, mintURL, true)
+	if err != nil {
+		return "", fmt.Errorf("failed to create payment token: %w", err)
+	}
+
+	// Validate token has proofs
+	if token == nil {
+		return "", fmt.Errorf("token creation returned nil token")
+	}
+
+	// Serialize token to string
+	tokenString, err := token.Serialize()
+	if err != nil {
+		return "", fmt.Errorf("failed to serialize token: %w", err)
+	}
+
+	// Validate serialized token is not empty
+	if tokenString == "" {
+		return "", fmt.Errorf("token serialization returned empty string")
+	}
+
+	log.Printf("Successfully created payment token: length=%d, token_preview=%s...",
+		len(tokenString), tokenString[:min(50, len(tokenString))])
+
+	return tokenString, nil
+}
+
+// CreatePaymentTokenWithOverpayment creates a payment token with overpayment capability
+func (m *Merchant) CreatePaymentTokenWithOverpayment(mintURL string, amount uint64, maxOverpaymentPercent uint64, maxOverpaymentAbsolute uint64) (string, error) {
+	// Use the tollwallet's new SendWithOverpayment method
+	tokenString, err := m.tollwallet.SendWithOverpayment(amount, mintURL, maxOverpaymentPercent, maxOverpaymentAbsolute)
+	if err != nil {
+		return "", fmt.Errorf("failed to create payment token with overpayment: %w", err)
+	}
+	return tokenString, nil
+}
+
+// GetAcceptedMints returns the list of accepted mints from the configuration
+func (m *Merchant) GetAcceptedMints() []config_manager.MintConfig {
+	return m.config.AcceptedMints
+}
+
+// GetBalance returns the total balance across all mints
+func (m *Merchant) GetBalance() uint64 {
+	return m.tollwallet.GetBalance()
+}
+
+// GetBalanceByMint returns the balance for a specific mint
+func (m *Merchant) GetBalanceByMint(mintURL string) uint64 {
+	return m.tollwallet.GetBalanceByMint(mintURL)
+}
+
+// GetSession retrieves a customer session by MAC address
+func (m *Merchant) GetSession(macAddress string) (*CustomerSession, error) {
+	m.sessionMu.RLock()
+	defer m.sessionMu.RUnlock()
+
+	session, exists := m.customerSessions[macAddress]
+	if !exists {
+		return nil, fmt.Errorf("session not found for MAC address: %s", macAddress)
+	}
+
+	return session, nil
+}
+
+// AddAllotment adds allotment to a customer session, creating it if it doesn't exist
+func (m *Merchant) AddAllotment(macAddress, metric string, amount uint64) (*CustomerSession, error) {
+	m.sessionMu.Lock()
+	defer m.sessionMu.Unlock()
+
+	session, exists := m.customerSessions[macAddress]
+	if !exists {
+		// Create new session
+		session = &CustomerSession{
+			MacAddress: macAddress,
+			StartTime:  time.Now().Unix(),
+			Metric:     metric,
+			Allotment:  amount,
+		}
+		m.customerSessions[macAddress] = session
+	} else {
+		// Add to existing session and reset start time to now
+		session.Allotment += amount
+		session.StartTime = time.Now().Unix()
+	}
+
+	return session, nil
+}
diff --git a/src/tollgate_protocol/go.mod b/src/tollgate_protocol/go.mod
new file mode 100644
index 0000000..31cf0b7
--- /dev/null
+++ b/src/tollgate_protocol/go.mod
@@ -0,0 +1,31 @@
+module github.com/OpenTollGate/tollgate-module-basic-go/src/tollgate_protocol
+
+go 1.24.1
+
+require github.com/nbd-wtf/go-nostr v0.51.10
+
+require (
+	github.com/ImVexed/fasturl v0.0.0-20230304231329-4e41488060f3 // indirect
+	github.com/btcsuite/btcd/btcec/v2 v2.3.4 // indirect
+	github.com/btcsuite/btcd/chaincfg/chainhash v1.1.0 // indirect
+	github.com/bytedance/sonic v1.13.1 // indirect
+	github.com/bytedance/sonic/loader v0.2.4 // indirect
+	github.com/cloudwego/base64x v0.1.5 // indirect
+	github.com/coder/websocket v1.8.12 // indirect
+	github.com/decred/dcrd/crypto/blake256 v1.1.0 // indirect
+	github.com/decred/dcrd/dcrec/secp256k1/v4 v4.4.0 // indirect
+	github.com/josharian/intern v1.0.0 // indirect
+	github.com/json-iterator/go v1.1.12 // indirect
+	github.com/klauspost/cpuid/v2 v2.2.10 // indirect
+	github.com/mailru/easyjson v0.9.0 // indirect
+	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
+	github.com/modern-go/reflect2 v1.0.2 // indirect
+	github.com/puzpuzpuz/xsync/v3 v3.5.1 // indirect
+	github.com/tidwall/gjson v1.18.0 // indirect
+	github.com/tidwall/match v1.1.1 // indirect
+	github.com/tidwall/pretty v1.2.1 // indirect
+	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
+	golang.org/x/arch v0.15.0 // indirect
+	golang.org/x/exp v0.0.0-20250305212735-054e65f0b394 // indirect
+	golang.org/x/sys v0.31.0 // indirect
+)
diff --git a/src/tollgate_protocol/go.sum b/src/tollgate_protocol/go.sum
new file mode 100644
index 0000000..aaf4b76
--- /dev/null
+++ b/src/tollgate_protocol/go.sum
@@ -0,0 +1,79 @@
+github.com/ImVexed/fasturl v0.0.0-20230304231329-4e41488060f3 h1:ClzzXMDDuUbWfNNZqGeYq4PnYOlwlOVIvSyNaIy0ykg=
+github.com/ImVexed/fasturl v0.0.0-20230304231329-4e41488060f3/go.mod h1:we0YA5CsBbH5+/NUzC/AlMmxaDtWlXeNsqrwXjTzmzA=
+github.com/btcsuite/btcd/btcec/v2 v2.3.4 h1:3EJjcN70HCu/mwqlUsGK8GcNVyLVxFDlWurTXGPFfiQ=
+github.com/btcsuite/btcd/btcec/v2 v2.3.4/go.mod h1:zYzJ8etWJQIv1Ogk7OzpWjowwOdXY1W/17j2MW85J04=
+github.com/btcsuite/btcd/chaincfg/chainhash v1.1.0 h1:59Kx4K6lzOW5w6nFlA0v5+lk/6sjybR934QNHSJZPTQ=
+github.com/btcsuite/btcd/chaincfg/chainhash v1.1.0/go.mod h1:7SFka0XMvUgj3hfZtydOrQY2mwhPclbT2snogU7SQQc=
+github.com/bytedance/sonic v1.13.1 h1:Jyd5CIvdFnkOWuKXr+wm4Nyk2h0yAFsr8ucJgEasO3g=
+github.com/bytedance/sonic v1.13.1/go.mod h1:o68xyaF9u2gvVBuGHPlUVCy+ZfmNNO5ETf1+KgkJhz4=
+github.com/bytedance/sonic/loader v0.1.1/go.mod h1:ncP89zfokxS5LZrJxl5z0UJcsk4M4yY2JpfqGeCtNLU=
+github.com/bytedance/sonic/loader v0.2.4 h1:ZWCw4stuXUsn1/+zQDqeE7JKP+QO47tz7QCNan80NzY=
+github.com/bytedance/sonic/loader v0.2.4/go.mod h1:N8A3vUdtUebEY2/VQC0MyhYeKUFosQU6FxH2JmUe6VI=
+github.com/cloudwego/base64x v0.1.5 h1:XPciSp1xaq2VCSt6lF0phncD4koWyULpl5bUxbfCyP4=
+github.com/cloudwego/base64x v0.1.5/go.mod h1:0zlkT4Wn5C6NdauXdJRhSKRlJvmclQ1hhJgA0rcu/8w=
+github.com/cloudwego/iasm v0.2.0/go.mod h1:8rXZaNYT2n95jn+zTI1sDr+IgcD2GVs0nlbbQPiEFhY=
+github.com/coder/websocket v1.8.12 h1:5bUXkEPPIbewrnkU8LTCLVaxi4N4J8ahufH2vlo4NAo=
+github.com/coder/websocket v1.8.12/go.mod h1:LNVeNrXQZfe5qhS9ALED3uA+l5pPqvwXg3CKoDBB2gs=
+github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
+github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
+github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
+github.com/decred/dcrd/crypto/blake256 v1.1.0 h1:zPMNGQCm0g4QTY27fOCorQW7EryeQ/U0x++OzVrdms8=
+github.com/decred/dcrd/crypto/blake256 v1.1.0/go.mod h1:2OfgNZ5wDpcsFmHmCK5gZTPcCXqlm2ArzUIkw9czNJo=
+github.com/decred/dcrd/dcrec/secp256k1/v4 v4.4.0 h1:NMZiJj8QnKe1LgsbDayM4UoHwbvwDRwnI3hwNaAHRnc=
+github.com/decred/dcrd/dcrec/secp256k1/v4 v4.4.0/go.mod h1:ZXNYxsqcloTdSy/rNShjYzMhyjf0LaoftYK0p+A3h40=
+github.com/dvyukov/go-fuzz v0.0.0-20200318091601-be3528f3a813/go.mod h1:11Gm+ccJnvAhCNLlf5+cS9KjtbaD5I5zaZpFMsTHWTw=
+github.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=
+github.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=
+github.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=
+github.com/json-iterator/go v1.1.12 h1:PV8peI4a0ysnczrg+LtxykD8LfKY9ML6u2jnxaEnrnM=
+github.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=
+github.com/klauspost/cpuid/v2 v2.0.9/go.mod h1:FInQzS24/EEf25PyTYn52gqo7WaD8xa0213Md/qVLRg=
+github.com/klauspost/cpuid/v2 v2.2.10 h1:tBs3QSyvjDyFTq3uoc/9xFpCuOsJQFNPiAhYdw2skhE=
+github.com/klauspost/cpuid/v2 v2.2.10/go.mod h1:hqwkgyIinND0mEev00jJYCxPNVRVXFQeu1XKlok6oO0=
+github.com/knz/go-libedit v1.10.1/go.mod h1:MZTVkCWyz0oBc7JOWP3wNAzd002ZbM/5hgShxwh4x8M=
+github.com/mailru/easyjson v0.9.0 h1:PrnmzHw7262yW8sTBwxi1PdJA3Iw/EKBa8psRf7d9a4=
+github.com/mailru/easyjson v0.9.0/go.mod h1:1+xMtQp2MRNVL/V1bOzuP3aP8VNwRW55fQUto+XFtTU=
+github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
+github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=
+github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
+github.com/modern-go/reflect2 v1.0.2 h1:xBagoLtFs94CBntxluKeaWgTMpvLxC4ur3nMaC9Gz0M=
+github.com/modern-go/reflect2 v1.0.2/go.mod h1:yWuevngMOJpCy52FWWMvUC8ws7m/LJsjYzDa0/r8luk=
+github.com/nbd-wtf/go-nostr v0.51.10 h1:MxyN/bRNqdeLbiN9lODbXduLRkYwy7SDTm73uGrsdU4=
+github.com/nbd-wtf/go-nostr v0.51.10/go.mod h1:IF30/Cm4AS90wd1GjsFJbBqq7oD1txo+2YUFYXqK3Nc=
+github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
+github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
+github.com/puzpuzpuz/xsync/v3 v3.5.1 h1:GJYJZwO6IdxN/IKbneznS6yPkVC+c3zyY/j19c++5Fg=
+github.com/puzpuzpuz/xsync/v3 v3.5.1/go.mod h1:VjzYrABPabuM4KyBh1Ftq6u8nhwY5tBPKP9jpmh0nnA=
+github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
+github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
+github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
+github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
+github.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
+github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
+github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
+github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
+github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
+github.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=
+github.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
+github.com/tidwall/gjson v1.18.0 h1:FIDeeyB800efLX89e5a8Y0BNH+LOngJyGrIWxG2FKQY=
+github.com/tidwall/gjson v1.18.0/go.mod h1:/wbyibRr2FHMks5tjHJ5F8dMZh3AcwJEMf5vlfC0lxk=
+github.com/tidwall/match v1.1.1 h1:+Ho715JplO36QYgwN9PGYNhgZvoUSc9X2c80KVTi+GA=
+github.com/tidwall/match v1.1.1/go.mod h1:eRSPERbgtNPcGhD8UCthc6PmLEQXEWd3PRB5JTxsfmM=
+github.com/tidwall/pretty v1.2.0/go.mod h1:ITEVvHYasfjBbM0u2Pg8T2nJnzm8xPwvNhhsoaGGjNU=
+github.com/tidwall/pretty v1.2.1 h1:qjsOFOWWQl+N3RsoF5/ssm1pHmJJwhjlSbZ51I6wMl4=
+github.com/tidwall/pretty v1.2.1/go.mod h1:ITEVvHYasfjBbM0u2Pg8T2nJnzm8xPwvNhhsoaGGjNU=
+github.com/twitchyliquid64/golang-asm v0.15.1 h1:SU5vSMR7hnwNxj24w34ZyCi/FmDZTkS4MhqMhdFk5YI=
+github.com/twitchyliquid64/golang-asm v0.15.1/go.mod h1:a1lVb/DtPvCB8fslRZhAngC2+aY1QWCk3Cedj/Gdt08=
+golang.org/x/arch v0.15.0 h1:QtOrQd0bTUnhNVNndMpLHNWrDmYzZ2KDqSrEymqInZw=
+golang.org/x/arch v0.15.0/go.mod h1:JmwW7aLIoRUKgaTzhkiEFxvcEiQGyOg9BMonBJUS7EE=
+golang.org/x/exp v0.0.0-20250305212735-054e65f0b394 h1:nDVHiLt8aIbd/VzvPWN6kSOPE7+F/fNFDSXLVYkE/Iw=
+golang.org/x/exp v0.0.0-20250305212735-054e65f0b394/go.mod h1:sIifuuw/Yco/y6yb6+bDNfyeQ/MdPUy/hKEMYQV17cM=
+golang.org/x/net v0.37.0 h1:1zLorHbz+LYj7MQlSf1+2tPIIgibq2eL5xkrGk6f+2c=
+golang.org/x/net v0.37.0/go.mod h1:ivrbrMbzFq5J41QOQh0siUuly180yBYtLp+CKbEaFx8=
+golang.org/x/sys v0.31.0 h1:ioabZlmFYtWhL+TRYpcnNlLwhyxaM9kWTDEmfnprqik=
+golang.org/x/sys v0.31.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
+gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
+gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
+gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
+gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
+nullprogram.com/x/optparse v1.0.0/go.mod h1:KdyPE+Igbe0jQUrVfMqDMeJQIJZEuyV7pjYmp6pbG50=
diff --git a/src/tollgate_protocol/validator.go b/src/tollgate_protocol/validator.go
new file mode 100644
index 0000000..3a040c0
--- /dev/null
+++ b/src/tollgate_protocol/validator.go
@@ -0,0 +1,159 @@
+package tollgate_protocol
+
+import (
+	"encoding/json"
+	"fmt"
+	"strconv"
+
+	"github.com/nbd-wtf/go-nostr"
+)
+
+// TollGateAdvertisementKind is the Nostr event kind for TollGate advertisements
+const TollGateAdvertisementKind = 10021
+
+// PricingOption represents a pricing option from an advertisement
+type PricingOption struct {
+	AssetType    string // "cashu"
+	PricePerStep uint64 // Price per step in units
+	PriceUnit    string // Price unit (e.g., "sat")
+	MintURL      string // Accepted mint URL
+	MinSteps     uint64 // Minimum steps to purchase
+}
+
+// AdvertisementInfo contains all pricing and configuration data extracted from an advertisement
+type AdvertisementInfo struct {
+	Metric         string          // "milliseconds" or "bytes"
+	StepSize       uint64          // Step size from advertisement
+	PricingOptions []PricingOption // Available pricing options
+	TIPs           []string        // Supported TIP numbers
+}
+
+// ValidateAdvertisement validates a TollGate advertisement
+// It checks if the nostr event is properly signed and has the correct kind
+func ValidateAdvertisement(event *nostr.Event) error {
+	if event == nil {
+		return fmt.Errorf("event is nil")
+	}
+
+	// Check if it's a TollGate advertisement kind
+	if event.Kind != TollGateAdvertisementKind {
+		return fmt.Errorf("invalid event kind: %d, expected %d", event.Kind, TollGateAdvertisementKind)
+	}
+
+	// Verify the event signature
+	ok, err := event.CheckSignature()
+	if err != nil {
+		return fmt.Errorf("signature verification failed: %w", err)
+	}
+	if !ok {
+		return fmt.Errorf("invalid signature")
+	}
+
+	return nil
+}
+
+// ParseAdvertisementFromBytes parses a TollGate advertisement from raw bytes
+func ParseAdvertisementFromBytes(data []byte) (*nostr.Event, error) {
+	var event nostr.Event
+	err := json.Unmarshal(data, &event)
+	if err != nil {
+		return nil, fmt.Errorf("failed to parse nostr event: %w", err)
+	}
+
+	return &event, nil
+}
+
+// ValidateAdvertisementFromBytes validates a TollGate advertisement from raw bytes
+func ValidateAdvertisementFromBytes(data []byte) (*nostr.Event, error) {
+	event, err := ParseAdvertisementFromBytes(data)
+	if err != nil {
+		return nil, err
+	}
+
+	err = ValidateAdvertisement(event)
+	if err != nil {
+		return nil, err
+	}
+
+	return event, nil
+}
+
+// ExtractAdvertisementInfo extracts pricing and configuration information from a TollGate advertisement
+func ExtractAdvertisementInfo(event *nostr.Event) (*AdvertisementInfo, error) {
+	if event == nil {
+		return nil, fmt.Errorf("event is nil")
+	}
+
+	if event.Kind != TollGateAdvertisementKind {
+		return nil, fmt.Errorf("invalid event kind: %d, expected %d", event.Kind, TollGateAdvertisementKind)
+	}
+
+	info := &AdvertisementInfo{
+		PricingOptions: []PricingOption{},
+		TIPs:           []string{},
+	}
+
+	// Extract information from tags
+	for _, tag := range event.Tags {
+		if len(tag) < 2 {
+			continue
+		}
+
+		switch tag[0] {
+		case "metric":
+			info.Metric = tag[1]
+
+		case "step_size":
+			stepSize, err := strconv.ParseUint(tag[1], 10, 64)
+			if err != nil {
+				return nil, fmt.Errorf("invalid step_size: %w", err)
+			}
+			info.StepSize = stepSize
+
+		case "price_per_step":
+			// Format: ["price_per_step", "cashu", "210", "sat", "https://mint.url", "1"]
+			if len(tag) < 6 {
+				continue // Skip malformed price_per_step tags
+			}
+
+			pricePerStep, err := strconv.ParseUint(tag[2], 10, 64)
+			if err != nil {
+				continue // Skip invalid prices
+			}
+
+			minSteps, err := strconv.ParseUint(tag[5], 10, 64)
+			if err != nil {
+				minSteps = 1 // Default to 1 if parsing fails
+			}
+
+			pricingOption := PricingOption{
+				AssetType:    tag[1],
+				PricePerStep: pricePerStep,
+				PriceUnit:    tag[3],
+				MintURL:      tag[4],
+				MinSteps:     minSteps,
+			}
+
+			info.PricingOptions = append(info.PricingOptions, pricingOption)
+
+		case "tips":
+			// All values after "tips" are TIP numbers
+			info.TIPs = append(info.TIPs, tag[1:]...)
+		}
+	}
+
+	// Validate required fields
+	if info.Metric == "" {
+		return nil, fmt.Errorf("missing required 'metric' tag")
+	}
+
+	if info.StepSize == 0 {
+		return nil, fmt.Errorf("missing or invalid 'step_size' tag")
+	}
+
+	if len(info.PricingOptions) == 0 {
+		return nil, fmt.Errorf("no valid pricing options found")
+	}
+
+	return info, nil
+}
diff --git a/src/tollwallet/go.mod b/src/tollwallet/go.mod
index fddbb62..3d3946f 100644
--- a/src/tollwallet/go.mod
+++ b/src/tollwallet/go.mod
@@ -4,7 +4,7 @@ go 1.24.2
 
 require (
 	github.com/OpenTollGate/tollgate-module-basic-go/src/lightning v0.0.0-00010101000000-000000000000
-	github.com/elnosh/gonuts v0.4.0
+	github.com/Origami74/gonuts-tollgate v0.6.1
 	github.com/stretchr/testify v1.10.0
 )
 
diff --git a/src/tollwallet/tollwallet.go b/src/tollwallet/tollwallet.go
index a5a78ea..e6fa812 100644
--- a/src/tollwallet/tollwallet.go
+++ b/src/tollwallet/tollwallet.go
@@ -5,8 +5,8 @@ import (
 	"log"
 
 	"github.com/OpenTollGate/tollgate-module-basic-go/src/lightning"
-	"github.com/elnosh/gonuts/cashu"
-	"github.com/elnosh/gonuts/wallet"
+	"github.com/Origami74/gonuts-tollgate/cashu"
+	"github.com/Origami74/gonuts-tollgate/wallet"
 )
 
 // TollWallet represents a Cashu wallet that can receive, swap, and send tokens
@@ -59,17 +59,74 @@ func (w *TollWallet) Receive(token cashu.Token) (uint64, error) {
 }
 
 func (w *TollWallet) Send(amount uint64, mintUrl string, includeFees bool) (cashu.Token, error) {
-	proofs, err := w.wallet.Send(amount, mintUrl, includeFees)
+	log.Printf("TollWallet.Send: attempting to send %d sats from mint %s (includeFees=%t)", amount, mintUrl, includeFees)
 
+	proofs, err := w.wallet.Send(amount, mintUrl, includeFees)
 	if err != nil {
+		log.Printf("TollWallet.Send: wallet.Send failed: %v", err)
 		return nil, fmt.Errorf("Failed to send %d to %s: %w", amount, mintUrl, err)
 	}
 
+	log.Printf("TollWallet.Send: received %d proofs from wallet.Send", len(proofs))
+
+	// Validate proofs array is not empty
+	if len(proofs) == 0 {
+		log.Printf("TollWallet.Send: ERROR - received empty proofs array from wallet.Send")
+		return nil, fmt.Errorf("wallet.Send returned empty proofs array for %d sats from %s", amount, mintUrl)
+	}
+
+	// Log proof details for debugging
+	totalProofAmount := uint64(0)
+	for i, proof := range proofs {
+		totalProofAmount += proof.Amount
+		log.Printf("TollWallet.Send: proof[%d]: amount=%d, secret=%s...", i, proof.Amount, proof.Secret[:min(10, len(proof.Secret))])
+	}
+	log.Printf("TollWallet.Send: total proof amount=%d (requested=%d)", totalProofAmount, amount)
+
 	token, err := cashu.NewTokenV4(proofs, mintUrl, cashu.Sat, true) // TODO: Support multi unit
+	if err != nil {
+		log.Printf("TollWallet.Send: NewTokenV4 failed: %v", err)
+		return nil, fmt.Errorf("Failed to create token: %w", err)
+	}
 
+	log.Printf("TollWallet.Send: successfully created token")
 	return token, nil
 }
 
+// SendWithOverpayment sends tokens with overpayment capability using gonuts SendWithOptions
+func (w *TollWallet) SendWithOverpayment(amount uint64, mintUrl string, maxOverpaymentPercent uint64, MaxOverpaymentAbsolute uint64) (string, error) {
+	// Set up send options with overpayment capability
+	options := wallet.SendOptions{
+		IncludeFees:            true,
+		AllowOverpayment:       true,
+		MaxOverpaymentPercent:  uint(maxOverpaymentPercent),
+		MaxOverpaymentAbsolute: MaxOverpaymentAbsolute,
+	}
+
+	// Use the gonuts SendWithOptions method
+	result, err := w.wallet.SendWithOptions(amount, mintUrl, options)
+	if err != nil {
+		return "", fmt.Errorf("failed to send with overpayment to %s: %w", mintUrl, err)
+	}
+
+	// Create token from the proofs
+	token, err := cashu.NewTokenV4(result.Proofs, mintUrl, cashu.Sat, true)
+	if err != nil {
+		return "", fmt.Errorf("failed to create token: %w", err)
+	}
+
+	// Encode token to string
+	tokenString, err := token.Serialize()
+	if err != nil {
+		return "", fmt.Errorf("failed to serialize token: %w", err)
+	}
+
+	log.Printf("Send successful with %d%% overpayment tolerance: requested=%d, overpayment=%d",
+		maxOverpaymentPercent, result.RequestedAmount, result.Overpayment)
+
+	return tokenString, nil
+}
+
 func (w *TollWallet) ParseToken(token string) (cashu.Token, error) {
 	return cashu.DecodeToken(token)
 }
diff --git a/src/tollwallet/tollwallet_test.go b/src/tollwallet/tollwallet_test.go
index 46473ae..e33443c 100644
--- a/src/tollwallet/tollwallet_test.go
+++ b/src/tollwallet/tollwallet_test.go
@@ -2,10 +2,9 @@ package tollwallet
 
 import (
 	"os"
-	"path/filepath"
 	"testing"
 
-	"github.com/elnosh/gonuts/cashu"
+	"github.com/Origami74/gonuts-tollgate/cashu"
 	"github.com/stretchr/testify/assert"
 	"github.com/stretchr/testify/mock"
 )
diff --git a/src/valve/go.mod b/src/valve/go.mod
index 13bb9d2..f6f1c9f 100644
--- a/src/valve/go.mod
+++ b/src/valve/go.mod
@@ -5,6 +5,7 @@ go 1.24.2
 require (
 	github.com/OpenTollGate/tollgate-module-basic-go/src/config_manager v0.0.0
 	github.com/nbd-wtf/go-nostr v0.51.11
+	github.com/sirupsen/logrus v1.9.3
 )
 
 require (
diff --git a/src/valve/valve.go b/src/valve/valve.go
index 570fbcf..95fe4d7 100644
--- a/src/valve/valve.go
+++ b/src/valve/valve.go
@@ -2,98 +2,38 @@ package valve
 
 import (
 	"fmt"
-	"log"
 	"os/exec"
-	"strconv"
 	"sync"
 	"time"
 
-	"github.com/OpenTollGate/tollgate-module-basic-go/src/config_manager"
-	"github.com/nbd-wtf/go-nostr"
+	"github.com/sirupsen/logrus"
 )
 
-// activeTimers keeps track of active timers for each MAC address
+// Module-level logger with pre-configured module field
+var logger = logrus.WithField("module", "valve")
+
+// openGates keeps track of MAC addresses that have been authorized
 var (
-	activeTimers = make(map[string]*time.Timer)
-	timerMutex   = &sync.Mutex{}
+	openGates  = make(map[string]*time.Timer)
+	gatesMutex = &sync.Mutex{}
 )
 
-// OpenGate authorizes a MAC address for network access for a specified duration
-func OpenGate(macAddress string, durationSeconds int64) error {
-	var durationMinutes int = int(durationSeconds / 60)
-
-	// The minimum of this tollgate is 1 min, otherwise it would default to 24h
-	if durationMinutes == 0 {
-		durationMinutes = 1
-	}
-
-	log.Printf("Opening gate for %s for the duration of %d minute(s)", macAddress, durationMinutes)
-
-	// Check if there's already a timer for this MAC address
-	timerMutex.Lock()
-	_, timerExists := activeTimers[macAddress]
-	timerMutex.Unlock()
-
-	// Only authorize the MAC address if there's no existing timer
-	if !timerExists {
-		err := authorizeMAC(macAddress)
-		if err != nil {
-			return fmt.Errorf("error authorizing MAC: %w", err)
-		}
-		log.Printf("New authorization for MAC %s", macAddress)
-	} else {
-		log.Printf("Extending access for already authorized MAC %s", macAddress)
-	}
-
-	// Cancel any existing timers for this MAC address
-	cancelExistingTimer(macAddress)
-
-	// Set up a new timer for this MAC address
-	duration := time.Duration(durationSeconds) * time.Second
-	timer := time.AfterFunc(duration, func() {
-		err := deauthorizeMAC(macAddress)
-		if err != nil {
-			log.Printf("Error deauthorizing MAC %s after timeout: %v", macAddress, err)
-		} else {
-			log.Printf("Successfully deauthorized MAC %s after timeout of %d minutes", macAddress, durationMinutes)
-		}
-
-		// Remove the timer from the map once it's executed
-		timerMutex.Lock()
-		delete(activeTimers, macAddress)
-		timerMutex.Unlock()
-	})
-
-	// Store the timer in the map
-	timerMutex.Lock()
-	activeTimers[macAddress] = timer
-	timerMutex.Unlock()
-
-	return nil
-}
-
-// cancelExistingTimer cancels any existing timer for the given MAC address
-func cancelExistingTimer(macAddress string) {
-	timerMutex.Lock()
-	defer timerMutex.Unlock()
-
-	if timer, exists := activeTimers[macAddress]; exists {
-		timer.Stop()
-		delete(activeTimers, macAddress)
-		log.Printf("Canceled existing timer for MAC %s", macAddress)
-	}
-}
-
 // authorizeMAC authorizes a MAC address using ndsctl
 func authorizeMAC(macAddress string) error {
 	cmd := exec.Command("ndsctl", "auth", macAddress)
 	output, err := cmd.Output()
 	if err != nil {
-		log.Printf("Error authorizing MAC address %s: %v", macAddress, err)
+		logger.WithFields(logrus.Fields{
+			"mac_address": macAddress,
+			"error":       err,
+		}).Error("Error authorizing MAC address")
 		return err
 	}
 
-	log.Printf("Authorization successful for MAC %s: %s", macAddress, string(output))
+	logger.WithFields(logrus.Fields{
+		"mac_address": macAddress,
+		"output":      string(output),
+	}).Info("Authorization successful for MAC")
 	return nil
 }
 
@@ -102,72 +42,87 @@ func deauthorizeMAC(macAddress string) error {
 	cmd := exec.Command("ndsctl", "deauth", macAddress)
 	output, err := cmd.Output()
 	if err != nil {
-		log.Printf("Error deauthorizing MAC address %s: %v", macAddress, err)
+		logger.WithFields(logrus.Fields{
+			"mac_address": macAddress,
+			"error":       err,
+		}).Error("Error deauthorizing MAC address")
 		return err
 	}
 
-	log.Printf("Deauthorization successful for MAC %s: %s", macAddress, string(output))
+	logger.WithFields(logrus.Fields{
+		"mac_address": macAddress,
+		"output":      string(output),
+	}).Debug("Deauthorization successful for MAC")
 	return nil
 }
 
-// GetActiveTimers returns the number of active timers for debugging
-func GetActiveTimers() int {
-	timerMutex.Lock()
-	defer timerMutex.Unlock()
-	return len(activeTimers)
-}
+// OpenGateUntil opens the gate (if not opened yet) and sets a timer until the timestamp.
+// If there is already a timer running, it will extend the timer.
+func OpenGateUntil(macAddress string, untilTimestamp int64) error {
+	now := time.Now().Unix()
 
-// OpenGateForSession authorizes network access based on a session event
-func OpenGateForSession(sessionEvent nostr.Event, config *config_manager.Config) error {
-	// Extract MAC address from session event
-	macAddress, err := extractMACFromSession(sessionEvent)
-	if err != nil {
-		return fmt.Errorf("failed to extract MAC address from session: %w", err)
-	}
+	// Calculate duration until the target timestamp
+	durationSeconds := untilTimestamp - now
 
-	// Extract allotment from session event
-	allotmentMs, err := extractAllotmentFromSession(sessionEvent)
-	if err != nil {
-		return fmt.Errorf("failed to extract allotment from session: %w", err)
+	// If the timestamp is in the past, return an error
+	if durationSeconds <= 0 {
+		return fmt.Errorf("timestamp %d is in the past (current time: %d)", untilTimestamp, now)
 	}
 
-	// Convert allotment to duration
-	durationSeconds := int64(allotmentMs / 1000)
+	logger.WithFields(logrus.Fields{
+		"mac_address":      macAddress,
+		"until_timestamp":  untilTimestamp,
+		"duration_seconds": durationSeconds,
+	}).Info("Opening gate until timestamp")
 
-	log.Printf("Opening gate for session: MAC=%s, allotment=%d ms, duration=%d seconds",
-		macAddress, allotmentMs, durationSeconds)
+	gatesMutex.Lock()
+	defer gatesMutex.Unlock()
 
-	// Use the existing OpenGate function
-	return OpenGate(macAddress, durationSeconds)
-}
+	// Check if the MAC is already in openGates
+	existingTimer, exists := openGates[macAddress]
 
-// extractMACFromSession extracts the MAC address from a session event
-func extractMACFromSession(sessionEvent nostr.Event) (string, error) {
-	for _, tag := range sessionEvent.Tags {
-		if len(tag) >= 3 && tag[0] == "device-identifier" && tag[1] == "mac" {
-			return tag[2], nil
+	if !exists {
+		// MAC not in openGates, authorize it
+		err := authorizeMAC(macAddress)
+		if err != nil {
+			return fmt.Errorf("error authorizing MAC: %w", err)
+		}
+		logger.WithFields(logrus.Fields{
+			"mac_address": macAddress,
+		}).Debug("New authorization for MAC")
+	} else {
+		// MAC already in openGates, stop the existing timer
+		if existingTimer != nil {
+			existingTimer.Stop()
 		}
+		logger.WithFields(logrus.Fields{
+			"mac_address": macAddress,
+		}).Debug("Extending access for already authorized MAC")
 	}
-	return "", fmt.Errorf("no MAC address found in session event")
-}
 
-// extractAllotmentFromSession extracts allotment from a session event
-func extractAllotmentFromSession(sessionEvent nostr.Event) (uint64, error) {
-	for _, tag := range sessionEvent.Tags {
-		if len(tag) >= 2 && tag[0] == "allotment" {
-			allotment, err := strconv.ParseUint(tag[1], 10, 64)
-			if err != nil {
-				return 0, fmt.Errorf("failed to parse allotment: %w", err)
-			}
-			return allotment, nil
+	// Create a new timer that will call deauthorizeMAC when it expires
+	duration := time.Duration(durationSeconds) * time.Second
+	timer := time.AfterFunc(duration, func() {
+		err := deauthorizeMAC(macAddress)
+		if err != nil {
+			logger.WithFields(logrus.Fields{
+				"mac_address": macAddress,
+				"error":       err,
+			}).Error("Error deauthorizing MAC after timeout")
+		} else {
+			logger.WithFields(logrus.Fields{
+				"mac_address": macAddress,
+			}).Debug("Successfully deauthorized MAC after timeout")
 		}
-	}
-	return 0, fmt.Errorf("no allotment found in session event")
-}
 
-// getStepSizeFromConfig gets the step size from configuration
-func getStepSizeFromConfig(config *config_manager.Config) uint64 {
-	// For now, return the default step size of 60000ms (1 minute)
-	// In a full implementation, this would parse the merchant's advertisement
-	return 60000
+		// Remove the MAC from openGates once timer expires
+		gatesMutex.Lock()
+		delete(openGates, macAddress)
+		gatesMutex.Unlock()
+	})
+
+	// Store the timer in openGates
+	openGates[macAddress] = timer
+
+	return nil
 }
diff --git a/src/valve/valve_test.go b/src/valve/valve_test.go
deleted file mode 100644
index 1997e88..0000000
--- a/src/valve/valve_test.go
+++ /dev/null
@@ -1,98 +0,0 @@
-package valve
-
-import (
-	"fmt"
-	"os"
-	"os/exec"
-	"testing"
-	"time"
-)
-
-func TestMain(m *testing.M) {
-	if _, err := exec.LookPath("ndsctl"); err != nil {
-		fmt.Println("ndsctl not found, skipping tests")
-		os.Exit(0)
-	}
-	m.Run()
-}
-
-func TestOpenGate(t *testing.T) {
-	macAddress := "00:11:22:33:44:55"
-	durationSeconds := int64(1) // 1 second for quick testing
-
-	err := OpenGate(macAddress, durationSeconds)
-	if err != nil {
-		t.Errorf("OpenGate failed: %v", err)
-	}
-
-	timerMutex.Lock()
-	_, timerExists := activeTimers[macAddress]
-	timerMutex.Unlock()
-	if !timerExists {
-		t.Errorf("Timer was not set for MAC %s", macAddress)
-	}
-
-	time.Sleep(time.Duration(durationSeconds+1) * time.Second)
-
-	timerMutex.Lock()
-	_, timerExists = activeTimers[macAddress]
-	timerMutex.Unlock()
-	if timerExists {
-		t.Errorf("Timer was not removed after expiration for MAC %s", macAddress)
-	}
-}
-
-func TestMultipleOpenGateCalls(t *testing.T) {
-	macAddress := "00:11:22:33:44:56"
-	durationSeconds := int64(2)
-
-	err := OpenGate(macAddress, durationSeconds)
-	if err != nil {
-		t.Errorf("First OpenGate call failed: %v", err)
-	}
-
-	err = OpenGate(macAddress, durationSeconds)
-	if err != nil {
-		t.Errorf("Second OpenGate call failed: %v", err)
-	}
-
-	timerMutex.Lock()
-	_, exists := activeTimers[macAddress]
-	timerMutex.Unlock()
-	if !exists {
-		t.Errorf("Timer was not reset for MAC %s", macAddress)
-	}
-
-	time.Sleep(time.Duration(durationSeconds+1) * time.Second)
-
-	timerMutex.Lock()
-	_, exists = activeTimers[macAddress]
-	timerMutex.Unlock()
-	if exists {
-		t.Errorf("Timer was not removed after expiration for MAC %s", macAddress)
-	}
-}
-
-func TestGetActiveTimers(t *testing.T) {
-	initialCount := GetActiveTimers()
-
-	macAddress := "00:11:22:33:44:57"
-	durationSeconds := int64(1)
-
-	err := OpenGate(macAddress, durationSeconds)
-	if err != nil {
-		t.Errorf("OpenGate failed: %v", err)
-	}
-
-	newCount := GetActiveTimers()
-	if newCount != initialCount+1 {
-		t.Errorf("GetActiveTimers returned %d, expected %d", newCount, initialCount+1)
-	}
-
-	time.Sleep(time.Duration(durationSeconds+1) * time.Second)
-
-	finalCount := GetActiveTimers()
-	if finalCount != initialCount {
-		t.Errorf("GetActiveTimers returned %d after timer expiration, expected %d", finalCount, initialCount)
-	}
-}
