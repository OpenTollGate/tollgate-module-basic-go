#!/bin/sh
# This script randomizes the LAN IP address of the OpenWRT router.
# It ensures that the router's LAN IP is not a common default (e.g., 192.168.1.1)
# and avoids unnecessary re-randomization on subsequent boots if an IP has already been set,
# or persists the current non-default IP if install.json is not properly populated.

INSTALL_JSON="/etc/tollgate/install.json"
# Function to check if an IP address is a common default vendor IP
is_default_ip() {
    local ip="$1"
    # Common default IPs: 192.168.1.1, 192.168.8.1, 192.168.X.1
    if echo "$ip" | grep -Eq "^192\.168\.(1|8|([0-9]{1,3}))\.1$"; then
        return 0 # It is a default IP
    else
        return 1 # It is not a default IP
    fi
}

# Determine if randomization or persistence is needed
RANDOMIZE_IP=0 # Assume no randomization by default
PERSIST_CURRENT_IP=0 # Assume no persistence by default
EXIT_EARLY=0 # Assume we don't exit early by default

CURRENT_LAN_IP=$(uci -q get network.lan.ipaddr)
echo "DEBUG: Current LAN IP: $CURRENT_LAN_IP"

STORED_RANDOM_IP="null"
if [ -f "$INSTALL_JSON" ]; then
    STORED_RANDOM_IP=$(jq -r '.ip_address_randomized // "null"' "$INSTALL_JSON")
fi
echo "DEBUG: Stored IP_RANDOMIZED in install.json: $STORED_RANDOM_IP"

if is_default_ip "$CURRENT_LAN_IP"; then
    echo "Current LAN IP is a default vendor IP. Will randomize."
    RANDOMIZE_IP=1
else
    # Current LAN IP is NOT a default IP.
    if [ -n "$STORED_RANDOM_IP" ] && [ "$STORED_RANDOM_IP" != "null" ]; then
        if echo "$STORED_RANDOM_IP" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$' && ! is_default_ip "$STORED_RANDOM_IP"; then
            if [ "$CURRENT_LAN_IP" = "$STORED_RANDOM_IP" ]; then
                echo "Current LAN IP matches stored randomized IP. No action needed."
                EXIT_EARLY=1
            else
                echo "Current LAN IP '$CURRENT_LAN_IP' does not match stored randomized IP '$STORED_RANDOM_IP'. Will re-randomize."
                RANDOMIZE_IP=1 # Re-randomize if current doesn't match stored valid random
            fi
        else
            echo "Stored IP '$STORED_RANDOM_IP' is invalid or a default IP. Will randomize."
            RANDOMIZE_IP=1
        fi
    else
        echo "install.json not found. Will randomize."
        RANDOMIZE_IP=1
    fi
fi

if [ "$RANDOMIZE_IP" -eq 1 ]; then
    # Update network config using UCI
    uci_safe_set network lan ipaddr "$RANDOM_IP"
    uci commit network
    
    # Update hosts file
    if grep -q "status.client" /etc/hosts; then
        # Replace existing entry
        sed -i "s/.*status\.client/$RANDOM_IP status.client/" /etc/hosts
    else
        # Add new entry
        echo "$RANDOM_IP status.client" >> /etc/hosts
    fi

    # NoDogSplash config check and update (only if installed)
    if [ -f "/etc/config/nodogsplash" ]; then
        if uci -q get nodogsplash.@nodogsplash[0] >/dev/null; then
            # statuspath is typically a URI path, not an IP
            # If you need to set it to a full URL:
            # uci set nodogsplash.@nodogsplash[0].statuspath="http://$RANDOM_IP/status"
            # uci commit nodogsplash
            echo "NoDogSplash detected, would update its config if needed"
        fi
    fi

    # Also update the default gateway and broadcast address accordingly
    NETMASK="255.255.255.0"  # Using standard /24 subnet
    uci_safe_set network lan netmask "$NETMASK"
    
    # Calculate subnet information for correct operation
    # For a /24 network, the broadcast is always x.y.z.255
    BROADCAST="$OCTET1.$OCTET2.$OCTET3.255"
    uci_safe_set network lan broadcast "$BROADCAST"
    
    # Schedule network restart (safer than immediate restart during boot)
    # This restart is crucial for the new IP to take effect.
    (sleep 5 && /etc/init.d/network restart &&
     [ -f "/etc/init.d/nodogsplash" ] && /etc/init.d/nodogsplash restart) &
    
    # Update install.json with the new random IP
    jq '.ip_address_randomized = "'"$RANDOM_IP"'"' "$INSTALL_JSON" > "$INSTALL_JSON.tmp" && mv "$INSTALL_JSON.tmp" "$INSTALL_JSON"
elif [ "$PERSIST_CURRENT_IP" -eq 1 ]; then
    echo "Persisting current LAN IP '$CURRENT_LAN_IP' to install.json."
    jq '.ip_address_randomized = "'"$CURRENT_LAN_IP"'"' "$INSTALL_JSON" > "$INSTALL_JSON.tmp" && mv "$INSTALL_JSON.tmp" "$INSTALL_JSON"
elif [ "$EXIT_EARLY" -eq 1 ]; then
    echo "IP is already randomized and set. Exiting 95-random-lan-ip."
    exit 0
fi

# Helper function to safely set UCI values with error handling
uci_safe_set() {
    local config="$1"
    local section="$2"
    local option="$3"
    local value="$4"
    
    # Check if the config exists
    if [ ! -f "/etc/config/$config" ]; then
        echo "Creating config: $config"
        touch "/etc/config/$config"
    fi
    
    # Check if the section exists
    if ! uci -q get "$config.$section" >/dev/null 2>&1; then
        # Section doesn't exist, try to create it
        if [[ "$section" == *"@"* ]]; then
            # For array sections like @dnsmasq[0], we need special handling
            # Extract the section type
            section_type=$(echo "$section" | cut -d'@' -f2 | cut -d'[' -f1)
            uci add "$config" "$section_type" >/dev/null 2>&1
        else
            # For named sections
            uci set "$config.$section=" >/dev/null 2>&1
        fi
    fi
    
    # Now set the option safely
    uci set "$config.$section.$option=$value" >/dev/null 2>&1
}

# Initialize random seed
RANDOM=$$$(date +%s)

# Randomly select one of the three private IP ranges:
# 1: 10.0.0.0/8
# 2: 172.16.0.0/12
# 3: 192.168.0.0/16
RANGE_SELECT=$((RANDOM % 3 + 1))

case $RANGE_SELECT in
    1)
        # 10.0.0.0/8 range
        OCTET1=10
        # Ensure we actually use the random values
        OCTET2=$((1 + RANDOM % 254))  # 1-254
        OCTET3=$((1 + RANDOM % 254))  # 1-254
        ;;
    2)
        # 172.16.0.0/12 range (172.16.x.x - 172.31.x.x)
        OCTET1=172
        OCTET2=$((RANDOM % 16 + 16))  # 16-31
        OCTET3=$((RANDOM % 256))
        ;;
    3)
        # 192.168.0.0/16 range
        OCTET1=192
        OCTET2=168
        OCTET3=$((RANDOM % 256))
        ;;
esac

# Avoid common third octets in the 192.168.x.x range to reduce conflicts
if [ $OCTET1 -eq 192 ] && [ $OCTET2 -eq 168 ]; then
    # Avoid common values like 0, 1, 100
    while [ $OCTET3 -eq 0 ] || [ $OCTET3 -eq 1 ] || [ $OCTET3 -eq 100 ]; do
        OCTET3=$((RANDOM % 256))
    done
fi

# Construct the random IP with last octet as 1
RANDOM_IP="$OCTET1.$OCTET2.$OCTET3.1"
echo "Setting random LAN IP to: $RANDOM_IP"

if [ "$RANDOMIZE_IP" -eq 1 ]; then
    # Update network config using UCI
    uci_safe_set network lan ipaddr "$RANDOM_IP"
    uci commit network

    # Update hosts file
    if grep -q "status.client" /etc/hosts; then
        # Replace existing entry
        sed -i "s/.*status\.client/$RANDOM_IP status.client/" /etc/hosts
    else
        # Add new entry
        echo "$RANDOM_IP status.client" >> /etc/hosts
    fi

    # NoDogSplash config check and update (only if installed)
    if [ -f "/etc/config/nodogsplash" ]; then
        if uci -q get nodogsplash.@nodogsplash[0] >/dev/null; then
            # statuspath is typically a URI path, not an IP
            # If you need to set it to a full URL:
            # uci set nodogsplash.@nodogsplash[0].statuspath="http://$RANDOM_IP/status"
            # uci commit nodogsplash
            echo "NoDogSplash detected, would update its config if needed"
        fi
    fi

    # Also update the default gateway and broadcast address accordingly
    NETMASK="255.255.255.0"  # Using standard /24 subnet
    uci_safe_set network lan netmask "$NETMASK"
    
    # Calculate subnet information for correct operation
    # For a /24 network, the broadcast is always x.y.z.255
    BROADCAST="$OCTET1.$OCTET2.$OCTET3.255"
    uci_safe_set network lan broadcast "$BROADCAST"

    # Schedule network restart (safer than immediate restart during boot)
    # This restart is crucial for the new IP to take effect.
    (sleep 5 && /etc/init.d/network restart &&
     [ -f "/etc/init.d/nodogsplash" ] && /etc/init.d/nodogsplash restart) &
    
    # Update install.json with the new random IP
    jq '.ip_address_randomized = "'"$RANDOM_IP"'"' "$INSTALL_JSON" > "$INSTALL_JSON.tmp" && mv "$INSTALL_JSON.tmp" "$INSTALL_JSON"
fi

exit 0
